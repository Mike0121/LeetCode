1:✖ 10.Oct.2023
解法への発想:
ビット演算でも行けるかと考えたが、複数同じ値を使えるので厳しい。
おそらく、for文で各要素を回し、while文で値がtargetを超えないと足し続けるような形にしたい。
しかし、"targetを超えない"が難しく、例えば"2"を3回入れてから他のを試すことにすると、
"7"は絶対入らなくなる。そこで、targetから値を引いていき、backtrackingを行う形にできないかを検討する。
**ベースケースは、index: iが最後の地点+1 = len(candidates)に達したとき。
そして、back_trackingを利用すれば、
まだ値を入れられる場合: back_tracking(i, target - candidates[i])
もう値を入れられず、次の値に移る場合: back_tracking(i+1, target)とすればよい。
popを行うのは、都度backtrackingを抜けたとき。これは、普通に考えればわかる。**

ちなみに、**どこかで"同じ値の利用(重複)を許してtargetを探す"問題を見た気がする**ので、あとで探しておく。

1. 関数の定義
関数を定義したい場合は、その関数を下に定義してもかまわないが、
class内の別の関数として外部に定義する必要がある。
また、別の関数としてクラス内に定義するためには、selfが必要である。

2. ans.append(helper[:])に関して
ans.append(helper[:]) における helper[:] は、helper リストの浅いコピー（shallow copy）を作成する。この方法でコピーを作成することで、helper リストの現在の内容をそのまま ans に追加することができる。
もし、**ans.append(helper) と直接追加すると、helper リストの参照が追加されるため、後に helper の内容が変更されると、ans に追加されたリストの内容も変わってしまう**が、helper[:] とすることで新しいリストのコピーが作成され、それが ans に追加されるので、**後の変更の影響を受けない**。
したがって、**ans.append(helper[:]) は、helper の現在の内容を保持した新しいリストを ans に追加する**という意味になる。

3. helperの挙動はどのようなものか？特に、helper.pop()は？