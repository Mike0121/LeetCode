## DFSによる解法 (8m25s)
時間計算量: O(N) <br>
空間計算量: O(N) <br>

> 解法が頭に入っていたため、比較的すんなり解けた。
> 自身で決めた変数名(関数名)が全く人と同じことが最近多い。
> graphという変数名は他にも良いものがありそう。

### 1回目 (10m15s)
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(node):
            seen.add(node)
            for neighbor_node in graph[node]:
                if neighbor_node not in seen:
                    visit_connected_nodes(neighbor_node)
        
        num_components = 0
        seen = set()
        for node in range(n):
            if node not in seen:
                visit_connected_nodes(node)
                num_components += 1
        return num_components
```

> ほぼ変更なし
### 2回目
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(node):
            seen.add(node)
            for neighbor_node in graph[node]:
                if neighbor_node not in seen:
                    visit_connected_nodes(neighbor_node)

        num_components = 0
        seen = set()
        for edge in range(n):
            if edge not in seen:
                visit_connected_nodes(edge)
                num_components += 1

        return num_components
```



### BFSによる解法
時間計算量: O(N) <br>
空間計算量: O(N) <br>

``` python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(start_node):
            next_nodes = deque([start_node])
            while next_nodes:
                node = next_nodes.popleft()
                seen.add(node)
                for neighbor_node in graph[node]:
                    if neighbor_node not in seen:
                        next_nodes.append(neighbor_node)

        num_components = 0
        seen = set()
        for edge in range(n):
            if edge not in seen:
                visit_connected_nodes(edge)
                num_components += 1
        return num_components
```


## UnionFindによる解法
一旦スキップ。時間に余裕ある時にUnion-Findの実装含めて取り組む。


