## DFSによる解法 (8m25s)
時間計算量: O(N) <br>
空間計算量: O(N) <br>

> 解法が頭に入っていたため、比較的すんなり解けた。
> 自身で決めた変数名(関数名)が全く人と同じことが最近多い。
> graphという変数名は他にも良いものがありそう。

### 1回目 (10m15s)
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(node):
            seen.add(node)
            for neighbor_node in graph[node]:
                if neighbor_node not in seen:
                    visit_connected_nodes(neighbor_node)
        
        num_components = 0
        seen = set()
        for node in range(n):
            if node not in seen:
                visit_connected_nodes(node)
                num_components += 1
        return num_components
```

> ほぼ変更なし
### 2回目
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(node):
            seen.add(node)
            for neighbor_node in graph[node]:
                if neighbor_node not in seen:
                    visit_connected_nodes(neighbor_node)

        num_components = 0
        seen = set()
        for edge in range(n):
            if edge not in seen:
                visit_connected_nodes(edge)
                num_components += 1

        return num_components
```

### 4回目
頂いたアドバイスを元に変数名の修正、また、seenをlistのflag立てるやり方に書き換えてみた。<br>
adjanctは、同意があればadjにしたい。<br>
```python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        adjacency_graph = defaultdict(list)

        for node_id1, node_id2 in edges:
            adjacency_graph[node_id1].append(node_id2)
            adjacency_graph[node_id2].append(node_id1)


        def visit_connected_nodes(node_id):
            for adjanct_node_id in adjacency_graph[node_id]:
                if seen[adjanct_node_id] == True:
                    continue
                
                seen[adjanct_node_id] = True
                visit_connected_nodes(adjanct_node_id)

        seen = [False for _ in range(n)] 
        num_components = 0
        for node_id in range(n):
            if seen[node_id] == True:
                continue
            visit_connected_nodes(node_id)
            num_components += 1
        return num_components
```


## BFSによる解法
時間計算量: O(N) <br>
空間計算量: O(N) <br>

``` python
class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        graph = defaultdict(list)
        for edge1, edge2 in edges:
            graph[edge1].append(edge2)
            graph[edge2].append(edge1)

        def visit_connected_nodes(start_node):
            next_nodes = deque([start_node])
            while next_nodes:
                node = next_nodes.popleft()
                seen.add(node)
                for neighbor_node in graph[node]:
                    if neighbor_node not in seen:
                        next_nodes.append(neighbor_node)

        num_components = 0
        seen = set()
        for edge in range(n):
            if edge not in seen:
                visit_connected_nodes(edge)
                num_components += 1
        return num_components
```


## UnionFindによる解法
一旦スキップ。時間に余裕ある時にUnion-Findの実装含めて取り組む。


