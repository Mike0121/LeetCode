## two-pointerによる解法
---
時間計算量: O(len(t))<br>
空間計算量: O(1)

### 1回目 (3m20s)
```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if s == "":
            return True
        s_index = 0

        for t_index in range(len(t)):
            if s[s_index] == t[t_index]:
                s_index += 1

            if s_index == len(s):
                return True
        return False
```


### 2回目
continueによる書き換え。
t_indexは利用せず、```python for t_letter in t```として直接文字と比較しても良いかと思った。

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if s == "":
            return True
        s_index = 0
        for t_index in range(len(t)):
            if s[s_index] != t[t_index]:
                continue
            
            s_index += 1
            if s_index == len(s):
                return True
        return False
```

## stackによる解法 (2m20s)
---
時間計算量: O(len(s) + len(t))<br>
空間計算量: O(len(s))<br>

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if s == "":
            return True
        s_letters = deque(s)

        for t_letter in t:
            if s_letters[0] == t_letter:
                s_letters.popleft()

            if not s_letters:
                return True
        return False
```

## 正規表現による解法
---
https://docs.python.org/ja/3/library/re.html#re.match

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        pattern = ""
        for letter in s:
            pattern += ".*" + letter
        return re.match(pattern, t) != None
```

## 関数型(っぽい)の解法 (kandaさんのstep2に該当)
見やすいのと、s == ""を例外として扱う必要がない。
```
関数型に関して: 
https://ja.wikipedia.org/wiki/%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0
関数を主軸にしたプログラミングを行うスタイルである。ここでの関数は、数学的なものを指し、引数の値が定まれば結果も定まるという参照透過性を持つものである。

参照透過性:
https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7
参照透過性とは、数学的な関数と同じように同じ値を返す式を与えたら必ず同じ値を返すような性質
```

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        si = 0
        ti = 0
        while True:
            if si == len(s):
               return True
            if ti == len(t):
                return False
            if s[si] == t[ti]:
                si += 1
            ti += 1    
```

## 最後に番兵を追加する方法
s == ""の例外ケース、ループ内での条件処理が不要。
```
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        s += "0"
        si, ti = 0, 0
        while ti < len(t):
            if s[si] == t[ti]:
                si += 1
            ti += 1
        return s[si] == "0"
```
