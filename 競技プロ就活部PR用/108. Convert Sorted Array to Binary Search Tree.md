### DFS(再帰)

時間計算量: O(N)<br>
空間計算量: O(N)<br>

---
### 1回目 (20m15s)
二分探索のアイデアでいけば書けることはパッと思いついたが、コードにうまくできず時間がかかった。
以前といた時よりはかなりアイデアそのものは簡単に感じた。
root.left, root.rightを作って、下から木を構築していく問題がやや苦手だが、今回の問題でかなり克服できたと考える。
(結果を伝播させていく問題はわかってきた。)


```py
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return []

        def sorted_array_to_bst_helper(left, right):
            if left > right:
                return

            mid_index = (left + right) // 2
            root = TreeNode(nums[mid_index])

            root.left = sorted_array_to_bst_helper(left, mid_index - 1)
            root.right = sorted_array_to_bst_helper(mid_index + 1, right)   

            return root         

        return sorted_array_to_bst_helper(0, len(nums) - 1)
```


### 2回目
left, mid, rightは、それぞれ_indexをつけるかつけないか統一した方が良いと考えた。
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        
        def sorted_array_to_bst_helper(left, right):
            if left > right:
                return
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = sorted_array_to_bst_helper(left, mid - 1)
            root.right = sorted_array_to_bst_helper(mid + 1, right)
            return root

        return sorted_array_to_bst_helper(0, len(nums) - 1)
```

### 3回目 (半開区間に変更)
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def sorted_array_to_bst_helper(left, right):
            if left == right:
                return 
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = sorted_array_to_bst_helper(left, mid)
            root.right = sorted_array_to_bst_helper(mid + 1, right)
            return root

        return sorted_array_to_bst_helper(0, len(nums))
```


### helper関数なし
---
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        mid = len(nums) // 2
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[:mid])
        root.right = self.sortedArrayToBST(nums[mid + 1:])

        return root
```

### DFS (スタック)

時間計算量: O(N)<br>
空間計算量: O(N)<br>

再帰をベースに考えて15分ほどで書いた。
---
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]: 
        if not nums:
            return [] 

        mid = (len(nums) - 1) // 2
        root = TreeNode(nums[mid])
        node_and_divided_array = [(root, nums[:mid], nums[mid+1:])]
        while node_and_divided_array:
            node, nums_left, nums_right = node_and_divided_array.pop()
             
            if nums_right:
                mid_right = (len(nums_right) - 1) // 2
                node.right = TreeNode(nums_right[mid_right])
                node_and_divided_array.append((node.right, nums_right[:mid_right], nums_right[mid_right+1:]))
            
            if nums_left:
                mid_left = (len(nums_left) - 1) // 2
                node.left = TreeNode(nums_left[mid_left])
                node_and_divided_array.append((node.left, nums_left[:mid_left], nums_left[mid_left+1:]))
               
        return root
```


### BFS

時間計算量: O(N)<br>
空間計算量: O(N)<br>

---
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]: 
        if not nums:
            return [] 

        mid = (len(nums) - 1) // 2
        root = TreeNode(nums[mid])
        node_and_divided_array = deque([(root, nums[:mid], nums[mid+1:])])
        while node_and_divided_array:
            node, nums_left, nums_right = node_and_divided_array.popleft()
            
            if nums_left:
                mid_left = (len(nums_left) - 1) // 2
                node.left = TreeNode(nums_left[mid_left])
                node_and_divided_array.append((node.left, nums_left[:mid_left], nums_left[mid_left+1:]))
                
            if nums_right:
                mid_right = (len(nums_right) - 1) // 2
                node.right = TreeNode(nums_right[mid_right])
                node_and_divided_array.append((node.right, nums_right[:mid_right], nums_right[mid_right+1:]))
            
        return root
```

