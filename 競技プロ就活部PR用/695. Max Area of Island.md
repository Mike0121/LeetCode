## 再帰(DFS)による解法
### 1回目 (6m5s)
時間計算量: O(N*M)<br>
空間計算量: O(N*M)<br>

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        WATER = 0
        ISLAND = 1
        grid_h = len(grid)
        grid_w = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        
        def count_island_area(h, w):
            if h < 0 or grid_h <= h or w < 0 or grid_w <= w or grid[h][w] == WATER:
                return 0
            grid[h][w] = WATER
            count = 1
            for move_h, move_w in moves:
                count += count_island_area(h + move_h, w + move_w)
            return count

        max_area = 0
        for i in range(grid_h):
            for j in range(grid_w):
                max_area = max(max_area, count_island_area(i, j))
        return max_area
```


### 2回目
> 類題: 200. Number of Islandの追加コメントを元に書き直し。<br>
> 関数名は、countよりcalculateの方がいいかと思った。<br>
> h, wの代わりにrow, columnに統一。(colがcolumnの略であることは場合によってはコメントで追記)<br>
> if文を反転。<br>
> gridを直接塗り替えたくない場合は、コピーを作成してvisitしたかを追う。<br>

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        WATER = 0
        ISLAND = 1
        num_rows = len(grid)
        num_cols = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]

        def calculate_island_area(row, col):
            if not (0 <= row < num_rows and 0 <= col < num_cols and grid[row][col] == ISLAND):
                return 0

            grid[row][col] = WATER
            island_area = 1

            for move_row, move_col in moves:
                island_area += calculate_island_area(row + move_row, col + move_col)
            return island_area
        
        maximum_area = 0
        for r in range(num_rows):
            for c in range(num_cols):
                if grid[r][c] == ISLAND:
                    maximum_area = max(maximum_area, calculate_island_area(r, c))
        return maximum_area
```


## キュー(BFS)による解法
時間計算量: O(N*M)
空間計算量: O(N*M)

```python
class Solution:
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        WATER = 0
        ISLAND = 1
        num_rows = len(grid)
        num_cols = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]

        def calculate_island_area(start_row, start_col):
            island_area = 0
            next_positions = deque([(start_row, start_col)])

            while next_positions:
                row, col = next_positions.popleft()
                if not (0 <= row < num_rows and 0 <= col < num_cols and grid[row][col] == ISLAND):
                    continue
                grid[row][col] = WATER
                island_area += 1
                for move_row, move_col in moves:
                    next_positions.append((row + move_row, col + move_col))

            return island_area
        
        maximum_area = 0
        for r in range(num_rows):
            for c in range(num_cols):
                if grid[r][c] == ISLAND:
                    maximum_area = max(maximum_area, calculate_island_area(r, c))

        return maximum_area
```


## UnionFindによる解法
一旦スキップ。時間に余裕ある時にUnion-Findの実装含めて取り組む。

