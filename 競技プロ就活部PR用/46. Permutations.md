## swapによる解答
---
### 1回目
そもそも手作業でどう解くべきかがピンと来ず、解けなかった。
自身で手作業で書き出していく中で、入れ替えを複数行えば良いことに気がついたが、
本番解けるかはかなり微妙。


```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        '''
        	bt(0)
            ├─ bt(1)
            │  ├─ bt(2)  # nums = [1, 2, 3]
            │  └─ bt(2)  # nums = [1, 3, 2] (2と3を入れ替え)
            ├─ bt(1)
            │  ├─ bt(2)  # nums = [2, 1, 3] (1と2を入れ替え)
            │  └─ bt(2)  # nums = [2, 3, 1] (1と3を入れ替え)
            └─ bt(1)
            ├─ bt(2)  # nums = [3, 2, 1] (1と3を入れ替え、その後2と3を入れ替え)
            └─ bt(2)  # nums = [3, 1, 2] (1と3を入れ替え)
        '''

        all_combinations = []

        def find_all_permutation(i):
            if i == len(nums):
                all_combinations.append(nums[:])
                return
            print(f"bt({i})")
            for j in range(i, len(nums)):
                nums[i], nums[j] = nums[j], nums[i]
                find_all_permutation(i + 1)
                nums[j], nums[i] = nums[i], nums[j]

        find_all_permutation(0) 
        return all_combinations
```


### 2~3回目
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []

        def find_all_permutation(i):
            if i == len(nums):
                all_permutations.append(nums[:])
                return
            for j in range(i, len(nums)):
                nums[i], nums[j] = nums[j], nums[i]
                find_all_permutation(i + 1)
                nums[j], nums[i] = nums[i], nums[j]

        find_all_permutation(0) 
        return all_permutations
```

## push,popを用いた解答
---

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []

        def find_all_permutations(permutation):
            if len(permutation) == len(nums):
                all_permutations.append(permutation[:])
            
            for num in nums:
                if num not in permutation:
                    permutation.append(num)
                    find_all_permutations(permutation)
                    permutation.pop()
                    
            
        find_all_permutations([])
        return all_permutations
```


## stackを用いた解答
---

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        all_permutations = []
        permutation_and_remain = [([], nums)]

        while permutation_and_remain:
            permutation, remain = permutation_and_remain.pop()

            if len(permutation) == len(nums):
                all_permutations.append(permutation)
                continue

            for i, num in enumerate(remain):
                permutation_and_remain.append((permutation + [num], remain[:i] + remain[i+1:]))

        return all_permutations
```



## モジュールを用いた解答
---
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        return [permutation for permutation in itertools.permutations(nums)]
```

https://docs.python.org/3/library/itertools.html#itertools.permutations

itertools permutationsの内部実装再現 (documentより)
```python
def permutations(iterable, r=None):
    # permutations('ABCD', 2) → AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) → 012 021 102 120 201 210
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r
    if r > n:
        return
    indices = list(range(n))
    cycles = list(range(n, n-r, -1))
    yield tuple(pool[i] for i in indices[:r])
    while n:
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices[i:] = indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield tuple(pool[i] for i in indices[:r])
                break
        else:
            return
```

 
