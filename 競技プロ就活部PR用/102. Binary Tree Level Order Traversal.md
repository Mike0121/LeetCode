15分で1回目は解けず、どのようにして同じ階層のノードを取り出して処理し、次の階層に移動するかが整理できませんでした。
各階層から値を列挙した後に、その回数分for文を回すのは、BFSの基本ができていないから思いつかなかった(考えられなかった)のかなと思います。

### 1回目
時間計算量: O(N)
空間計算量: O(N + 正解分)
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        next_level_nodes = deque()
        next_level_nodes.append(root)

        while next_level_nodes:
            same_level_nodes = []
            for i in range(len(next_level_nodes)):
                node = next_level_nodes.popleft()
                same_level_nodes.append(node.val)

                if node.left:
                    next_level_nodes.append(node.left)
                    
                if node.right:
                    next_level_nodes.append(node.right)
                    
            result.append(same_level_nodes)

        return result
```


理屈が頭の中にある程度整理されていれば、余計な改行が減る気がしました。

 ### 2回目
 ```python
 class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        next_level_nodes = deque()
        next_level_nodes.append(root)

        while next_level_nodes:
            same_level_nodes = []
            for _ in range(len(next_level_nodes)):
                node = next_level_nodes.popleft()
                same_level_nodes.append(node.val)
                if node.left:
                    next_level_nodes.append(node.left)
                if node.right:
                    next_level_nodes.append(node.right)

            result.append(same_level_nodes)
        return result
```

next_level_nodes, same_level_valuesは、next_level, same_levelでも良いかと思った。

 ### 3回目
 ```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        result = []
        next_level_nodes = deque()
        next_level_nodes.append(root)

        while next_level_nodes:
            same_level_values = []
            
            for _ in range(len(next_level_nodes)):
                node = next_level_nodes.popleft()
                same_level_values.append(node.val)
                if node.left:
                    next_level_nodes.append(node.left)
                if node.right:
                    next_level_nodes.append(node.right)
            result.append(same_level_values)
        
        return result
 ```


### 4回目 (listによる解答)
```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        
        level_ordered_values = []
        current_level_nodes = [root]

        while current_level_nodes:
            same_level_values = []
            next_level_nodes = []
            
            for i in range(len(current_level_nodes)):
                node = current_level_nodes[i]
                same_level_values.append(node.val)
                if node.left:
                    next_level_nodes.append(node.left)
                if node.right:
                    next_level_nodes.append(node.right)
            current_level_nodes = next_level_nodes
            level_ordered_values.append(same_level_values)
        
        return level_ordered_values
```
