## スタックによる解法 (4m20s)
* 時間計算量: O(N)
* 空間計算量: O(N)

### 1回目
* かなりシンプルに思いついた。繋ぎかえとどちらの解法を書くか迷ったが、事故をさけるため本番ではこちらを書くと思う。
* ただ、ループを2回回しているのと、stackを使っているので、計算量がO(2N), O(2N)になるので、厳密には繋ぎかえの方が良さそう。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        dummy_head = dummy
        
        nodes = []
        while head:
            nodes.append(head.val)
            head = head.next

        while nodes:
            value = nodes.pop()
            dummy.next = ListNode(value)
            dummy = dummy.next
        
        return dummy_head.next
```


### 2回目
* dummyではなく、reversed_listと命名した方が良さそうなので変更。

```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        reversed_list = ListNode()
        reversed_list_head = reversed_list
        
        nodes = []
        while head:
            nodes.append(head.val)
            head = head.next

        while nodes:
            value = nodes.pop()
            reversed_list.next = ListNode(value)
            reversed_list = reversed_list.next
        
        return reversed_list_head.next
```

## 繋ぎかえによる解法 (7m20s)

* reversed_list = headの行が少しトリッキーに感じた。
(1 -> Noneにした後、1(繋ぎかえを行った後の末尾のhead)にreversed_listのポインタを移動する。)

### 1回目
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None

        reversed_list = None
        node = head

        while node:
            next_node = node.next
            node.next = reversed_list
            reversed_list = node
            node = next_node

        return reversed_list
```

### 2回目
* headを再度頭から見ることがなければ、currentは不要。
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None
        reversed_list = None
        
        while head:
            head_next = head.next
            head.next = reversed_list
            reversed_list = head
            head = head_next

        return reversed_list
```


### 3回目
* 2回目から特に変化なし
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None

        reversed_list = None
        while head:
            next_node = head.next
            head.next = reversed_list
            reversed_list = head
            head = next_node

        return reversed_list
```

## 再帰による解法
* 書けなかった。最後のノードまで先に到達させるとして、どのようにそれを繋ぎかえるかがわからなかったが、よく考えれば繋ぎかえを丁寧にやれば良いだけだった。
* ただ、2変数を変える発想がなかったのが、まだ慣れていない(丁寧に思考できていない)か。
* https://github.com/kagetora0924/leetcode-grind/commit/02957f94e51b1b9a245351e5d3aa1e7514079421さんのコードが見やすかったので参照した。
* また、右記も参考にした。https://discord.com/channels/1084280443945353267/1231966485610758196/1239417493211320382

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def reverse_list_helper(node):
            if not node or not node.next:
                return node, node
        
            head, tail = reverse_list_helper(node.next)    
            tail.next = node
            node.next = None
            return head, node

        new_head, _ = reverse_list_helper(head)
        return new_head
```
