46. Permutationsの入れ替えを理解するために解いた。
解けずに参考を見て、なぜこれで要件を満たすか悩んだが、理解してからは比較的素直にコードにすることができた。

### 1回目
時間計算量: O(N)<br>
空間計算量: O(1)<br>

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def find_pos_desc_in_reversed(arr):
            for i in range(len(arr) - 2, -1 , -1):
                if arr[i] < arr[i+1]:
                    return i
            return -1

        def find_larger_index_of_subarr(arr, left):
            i = len(arr) - 1
            while arr[i] <= arr[left]:
                i -= 1
            return i

        left_index = find_pos_desc_in_reversed(nums)
        if left_index == -1:
            nums.reverse()
            return

        right_index = find_larger_index_of_subarr(nums, left_index)
        nums[left_index], nums[right_index] = nums[right_index], nums[left_index]

        left_index += 1
        right_index = len(nums) - 1
        while left_index < right_index:
            nums[left_index], nums[right_index] = nums[right_index], nums[left_index]
            left_index += 1
            right_index -= 1
```

### 2~3回目
関数名に違和感があったので、SuperHotDogCatさんの関数名を参考に修正。
left, rightは、pivot, swapの方がわかりやすいかもしれない。
https://github.com/SuperHotDogCat/coding-interview/blob/b90357b0a2f827d7d448aea0a607628dedcf897a/next_permutation/phase7.py

時間計算量: 1回目と同じ<br>
空間計算量: 1回目と同じ<br>

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def find_pos_desc_in_reversed(arr: List[int]) -> int:
            for i in range(len(arr) - 2, -1, -1):
                if arr[i] < arr[i + 1]:
                    return i
            return -1

        def find_larger_index_of_subarr(arr: List[int], left: int) -> int:
            i = len(arr) - 1
            while arr[i] <= arr[left]:
                i -= 1
            return i

        left_index = find_pos_desc_in_reversed(nums)
        if left_index == -1:
            nums.reverse()
            return

        right_index = find_larger_index_of_subarr(nums, left_index)
        nums[left_index], nums[right_index] = nums[right_index], nums[left_index]

        left_index, right_index = left_index + 1, len(nums) - 1
        while left_index < right_index:
            nums[left_index], nums[right_index] = nums[right_index], nums[left_index]
            left_index += 1
            right_index -= 1
```

## 二重ループによる解法

時間計算量: O(N\*N\*M) (二重ループ*スライス操作)<br>
空間計算量: O(N)

```python
class Solution:
    def nextPermutation(self, nums: list[int]) -> None:
        for pivot_index in range(len(nums) - 2, -1, -1):
            for swap_index in range(len(nums) - 1, pivot_index, -1):
                if nums[pivot_index] < nums[swap_index]:
                    nums[pivot_index], nums[swap_index] = nums[swap_index], nums[pivot_index]
                    nums[pivot_index+1:] = nums[pivot_index+1:][::-1]
                    return
        nums.reverse()
```
