
### 0回目 (全探索による解法)

時間計算量: O(N * M * logk)<br>
空間計算量: O(k)<br>
(N: len(nums1), M: len(nums2))

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        heap = []
        for num1 in nums1:
            for num2 in nums2:
                heapq.heappush(heap, (-1 * (num1 + num2), [num1, num2]))
                if len(heap) > k:
                    heapq.heappop(heap)
    
        return [x for _, x in heap]
```


nums1, nums2がソートされていることを使えないか手で何度か計算してみたが、あまり良いロジックが思い浮かばず
以前の自分の解法を参考に書き直してみたが、かなり違和感(わかりづらさ)を感じた。
特に違和感を感じた点として、
1. 最初にnums1の値とnums2の最小値を加えているが、手でやる時にこれはしない。
2. kを減らしていっているが、最終的な結果(k_smallest_sum_pairs)がkを越えるまで追加する方が素直。

###  1回目

時間計算量: O(N + k)<br>
空間計算量: O(N + k)<br>
(N: len(nums1))

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        candidates = []
        k_smallest_sum_pairs = []
        for num1 in nums1:
            heapq.heappush(candidates, [num1 + nums2[0], 0])

        while candidates and k > 0:
            element_sum, index = heapq.heappop(candidates)
            k_smallest_sum_pairs.append([element_sum - nums2[index], nums2[index]])

            if index + 1 < len(nums2):
                heapq.heappush(candidates, [element_sum - nums2[index] + nums2[index + 1], index + 1])
            k -= 1

        return k_smallest_sum_pairs
```

### 2~3回目 ★

時間計算量: O(k * logk)<br>
空間計算量: O(k)<br>

Odaさんの縦横の表を埋めていくコメントを基に、DFSの発想でやった。発想がわかったあとは、比較的スラスラかけた。(約6分)
- 空間計算量を最適化しようとしすぎていた。(heapにはどんどん追加していき、都度最小値を取り出す。)
- 最初にSubmitしたコードでは、2回通る部分を考慮しておらず、エラーが出てしまった。
- heapの変数名は、sum_and_indicesでも良いかと思ったが全体でみるとやや冗長な感じがした。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        heap = [(nums1[0] + nums2[0], 0, 0)]
        heapq.heapify(heap)
        k_smallest_sum_pairs = []
        visited = set()

        while heap and len(k_smallest_sum_pairs) < k:
            element_sum, index1, index2 = heapq.heappop(heap)
            k_smallest_sum_pairs.append([nums1[index1], nums2[index2]])

            if index1 + 1 < len(nums1) and (index1 + 1, index2) not in visited:
                heapq.heappush(heap, (nums1[index1 + 1] + nums2[index2], index1 + 1, index2))
                visited.add((index1 + 1, index2))
            
            if index2 + 1 < len(nums2) and (index1, index2 + 1) not in visited:
                heapq.heappush(heap, (nums1[index1] + nums2[index2 + 1], index1, index2 + 1))
                visited.add((index1, index2 + 1))
        
        return k_smallest_sum_pairs            
```


### 4回目
```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        candidates = [(nums1[0] + nums2[0], 0, 0)]
        heapq.heapify(candidates)
        k_smallest_sum_pairs = []
        visited = set((0, 0))

        def maybe_heappush(heap, pos1, pos2):
            if pos1 < len(nums1) and pos2 < len(nums2) and (pos1, pos2) not in visited:
                if pos1 == 0 or pos2 == 0 or ((pos1 - 1, pos2) in visited and (pos1, pos2 - 1) in visited):
                    heapq.heappush(heap, (nums1[pos1] + nums2[pos2], pos1, pos2))
                    visited.add((pos1, pos2))

        while len(k_smallest_sum_pairs) < k and candidates:
            _, index1, index2 = heapq.heappop(candidates)
            k_smallest_sum_pairs.append([nums1[index1], nums2[index2]])

            maybe_heappush(candidates, index1 + 1, index2)
            maybe_heappush(candidates, index1, index2 + 1)

        return k_smallest_sum_pairs
```


