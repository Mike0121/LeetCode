## Sortによる解法　★
### 1回目 (3m01s)
anagramを探す場合sortすれば良いことが頭に入っていたため、かなりすんなり解けた。<br>
時間計算量: O(N)<br>
空間計算量: O(N) sortされた文字列 + dict分 + 最終結果分<br>
N: len(s)
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        anagrams = defaultdict(list)
        for s in strs:
            sorted_s = "".join(sorted(s))
            anagrams[sorted_s].append(s)

        all_anagram_pairs = []
        for anagram_list in anagrams.values():
            all_anagram_pairs.append(anagram_list)
        return all_anagram_pairs
```

Note:
- 返り値がList[List]であること。(.valuesをそのまま返さない。)
- Listをstr()すると、'['a', 'b', 'c']'のようになる。


### 2回目
1回目の書き方はやや冗長であったため、簡潔にした。
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        word_to_anagram = defaultdict(list)

        for word in strs:
            word_to_anagram["".join(sorted(word))].append(word)

        return list(word_to_anagram.values())
```

## 度数分布を利用した解法　★
参照: https://docs.python.org/ja/3/library/functions.html#ord<br>
時間計算量: O(N*M)<br>
空間計算量: O(N*M)<br>
N: len(strs), M: strs内の最大の文字列<br>
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        def string_to_histgram(word):
            char_appear_histgram = [0] * (ord('z') - ord('a') + 1)
            for c in word:
                char_appear_histgram[ord(c) - ord('a')] += 1
            return tuple(char_appear_histgram)

        word_to_anagrams = defaultdict(list)
        for s in strs:
            word_to_anagrams[string_to_histgram(s)].append(s)

        return list(word_to_anagrams.values())
```

## Group Byによる解法
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        word_to_anagrams = defaultdict(list)
        for key, group in groupby(strs, key = lambda s: ''.join(sorted(s))):
            word_to_anagrams[key] += (list(group))

        return list(word_to_anagrams.values())
```
