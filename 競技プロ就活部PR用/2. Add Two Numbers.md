## whileによる解法
* 時間計算量: O(N)
* 空間計算量: O(N)

### 1回目 (14m25s)
* ビット演算で似た問題を解いていたので、指針は思いついた。
* 最初のノードの計算を特別扱いしているが、これは無くせそう。


```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode((l1.val + l2.val) % 10)
        dummy_head = dummy
        carry = (l1.val + l2.val) // 10

        current1 = l1
        current2 = l2
        
        if current1: current1 = current1.next
        if current2: current2 = current2.next

        while current1 or current2 or carry:
            val1 = current1.val if current1 else 0
            val2 = current2.val if current2 else 0

            dummy.next = ListNode((val1 + val2 + carry) % 10)
            dummy = dummy.next
            carry = (val1 + val2 + carry) // 10

            if current1: current1 = current1.next
            if current2: current2 = current2.next

        return dummy_head
```

### 2回目
* 1回目の計算の特別扱いを修正。
* dummyの初期化時に0を明示しなくても良さそう。
```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        dummy_head = dummy
        carry = 0
        current1 = l1
        current2 = l2

        while current1 or current2 or carry:
            val1 = current1.val if current1 else 0
            val2 = current2.val if current2 else 0

            dummy.next = ListNode((val1 + val2 + carry) % 10)
            dummy = dummy.next
            carry = (val1 + val2 + carry) // 10

            if current1: current1 = current1.next
            if current2: current2 = current2.next

        return dummy_head.next
```


### 3回目
他参加者の参考になった点として、
* val1 = current1.val if current1 else 0の部分をget_valueとして関数化
* dummyの変数名を代わりにsentinelにする。
* totalでval1 + val2 + carryを変数化
を採用してみる。

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        def get_value(node: Optional[ListNode]) -> int:
            if node is None:
                return 0
            return node.val
        
        sentinel = ListNode()
        sentinel_head = sentinel
        carry = 0

        while l1 or l2 or carry:
            value1 = get_value(l1)
            value2 = get_value(l2)

            total = value1 + value2 + carry
            sentinel.next = ListNode(total % 10)
            sentinel = sentinel.next
            carry = total // 10

            if l1: l1 = l1.next
            if l2: l2 = l2.next

        return sentinel_head.next
```


## 再帰による解法
* 比較的すんなり書き換えられた。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        def get_value(node: Optional[ListNode]) -> int:
            if node is None:
                return 0
            return node.val

        def next_node(node: Optional[ListNode]) -> Optional[ListNode]:
            if node is None:
                return None
            return node.next

        def _add_two_numbers_helper(node1: Optional[ListNode] , node2: Optional[ListNode], carry: int) -> Optional[ListNode]:
            if not (node1 or node2 or carry):
                return None
            
            value1 = get_value(node1)
            value2 = get_value(node2)
            total = value1 + value2 + carry
            node = ListNode(total % 10)
            carry = total // 10
            node.next = _add_two_numbers_helper(next_node(node1), next_node(node2), carry)
            return node

        return _add_two_numbers_helper(l1, l2, 0)
```
