```
問題文
Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.

Example 1:
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

Example 2:
Input: intervals = [[7,10],[2,4]]
Output: 1

Constraints:

0 <= intervals.length <= 10^4
intervals[i].length == 2
0 <= starti < endi <= 10^6
```


## Heapによる解法
---
### 1回目
時間計算量: O(NlogN)<br>
空間計算量: O(k)<br>
N: len(intervals), k: heapの最大の長さ<br>
LeetcodeのDiscussionをヒントに解いた。<br>
meetingが最小のendより前に完了している場合のみheapからpopし、都度heapに終了時間を加えていく。
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        intervals.sort()
        rooms_end = []
        heapq.heappush(rooms_end, intervals[0][1])
        for interval in intervals[1:]:
            start, end = interval
            if start >= rooms_end[0]:
                heapq.heappop(rooms_end)
            heapq.heappush(rooms_end, end)

        return len(rooms_end)
```


### 2回目
時間計算量: O(NlogN)<br>
空間計算量: O(N)<br>

より手でやる方法に近く、人の出入りをmeetingが始まるor終わるでカウントし、最大のmeetingが行われている方法を都度記録する方法で実装。
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        meetings = []
        for interval in intervals:
            start, end = interval
            heapq.heappush(meetings, (start, "start"))
            heapq.heappush(meetings, (end, "end"))
        
        max_num_rooms = 0
        num_rooms = 0
        while meetings:
            time, status = heapq.heappop(meetings)
            if status == "start":
                num_rooms += 1
            else:
                num_rooms -= 1

            max_num_rooms = max(max_num_rooms, num_rooms)

        return max_num_rooms
```


### 3回目
時間計算量: O(NlogN)<br>
空間計算量: O(N)<br>

2回目の方が手の感覚に近いため、これを参照に、statusがendの場合はmaxを更新する必要がないことを考慮にして書き直し。
```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        meetings = []
        for interval in intervals:
            start, end = interval
            heapq.heappush(meetings, (start, "start"))
            heapq.heappush(meetings, (end, "end"))

        num_rooms = 0
        max_num_rooms = 0
        while meetings:
            _, status = heapq.heappop(meetings)
            if status == "end":
                num_rooms -= 1
                continue

            num_rooms += 1
            max_num_rooms = max(max_num_rooms, num_rooms)

        return max_num_rooms
```

### 4回目
- heapの代わりに、素直にlistを利用してソート
- MEETING_START, MEETING_ENDを表すダミー定数を用意し、コメントを付記

```python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        # Constants to represent the type of event
        MEETING_START = 1 # The start of a meeting
        MEETING_END = 0 # The end of a meeting
        meetings = []
        for start, end in intervals:
            meetings.append((start, MEETING_START))
            meetings.append((end, MEETING_END))

        running_rooms = 0
        required_rooms = 0

        for _, status in sorted(meetings):
            if status == 0:
                running_rooms -= 1
                continue
            running_rooms += 1
            required_rooms = max(required_rooms, running_rooms)
    
        return required_rooms
```
