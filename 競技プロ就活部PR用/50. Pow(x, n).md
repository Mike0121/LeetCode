```
負の数の割り算と余り、言語によって振る舞いが色々なので自分の使い慣れたものについては覚えておきましょう。
```

## 計算式による解法
---
時間計算量: O(1)<br>
空間計算量: O(1)<br>
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return float(x ** n)
```

## 再帰による解法 (maximum recursion depth exceeded)
---

### 1回目
時間計算量: O(N)<br>
空間計算量: O(N)<br>
よく考えたら、```if n == 1: return x```は不要。
また、n == -1 は、最初にnが正負かで値の更新を行った方が、わかりやすい。
(2回目以降で反映。)

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n == 1:
            return x
        if n == -1:
            return 1 / x
 
        return x * self.myPow(x, n - 1) if n > 0 else 1 / x * self.myPow(x, n + 1)
```

### 2回目
時間計算量: O(logN)<br>
空間計算量: O(logN)<br>

分割統治法のイメージで書いたが、直感的に何をしているのかわかづらい。
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1 / x
            n *= -1
        
        divided_prod = self.myPow(x, n // 2)
        if n % 2 == 0:
            return divided_prod * divided_prod
        else:
            return divided_prod * divided_prod * x
```

### 3回目
時間計算量: O(logN)<br>
空間計算量: O(logN)<br>
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            x = 1 /x
            n *= -1
        if n % 2 == 0:
            return self.myPow(x * x, n // 2)  
        else:
            return x * self.myPow(x * x, n // 2)
```



## Interationによる解法
---
時間計算量: O(logN)<br>
空間計算量: O(logN)<br>
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n < 0:
            x = 1 /x
            n *= -1

        accumulated_prod = 1 
        while n > 0:
            if n % 2 != 0:
                accumulated_prod *= x
            x *= x
            n //= 2
            
        return accumulated_prod
```
