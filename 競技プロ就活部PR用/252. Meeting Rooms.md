問題文
```
Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.
Example 1:

Input: intervals = [[0,30],[5,10],[15,20]]
Output: false
Example 2:

Input: intervals = [[7,10],[2,4]]
Output: true
```

### 1回目 (4m52s)
時間計算量: O(NlogN) (ソートによる計算量)<br>
空間計算量: O(N)<br>
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        ordered_intervals = sorted(intervals, key = lambda x: x[1])
        prev_end = 0
        for interval in ordered_intervals:
            start, end = interval[0], interval[1]
            if start < prev_end:
                return False
            prev_end = end
        return True
```

1回目の自分のコードを参考に、下記を修正。
- start, end = interval[0], interval[1] -> start, end = interval
- sortedで開始時間を基にsortすれば良いので、sorted(intervals)でOK。
- intervals.sort()でも良い。

### 2回目
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        ordered_intervals = sorted(intervals)
        prev_end = 0
        for interval in ordered_intervals:
            start, end = interval
            if start < prev_end:
                return False
            prev_end = end
        return True
```

### 3回目
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        previous_end = 0
        for start, end in sorted(intervals):
            if start < previous_end:
                return False
            previous_end = end
        return True
```
        


## Heapによる解法
時間計算量: O(NlogN) heappop分<br>
空間計算量: O(1)<br>

```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        heapq.heapify(intervals)
        prev_end = 0
        while intervals:
            start, end = heapq.heappop(intervals)
            if start < prev_end:
                return False
            prev_end = end
        return Truee
```
