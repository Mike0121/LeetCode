## Deque, OrderedDictによる解法
### 1回目 (dequeによる解法) (16m20s) 
* 問題文を読みながら書いたが、これだとputのremoveの部分で最悪計算量がO(N)になってしまう。
* OrderedDictを利用すれば良いことを知る。
* 前提として、capaictyは1以上。

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.order = deque()
        
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        else:
            self.order.remove(key)
            self.order.append(key)
            return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.order.remove(key)
            
        elif len(self.cache) == self.capacity:
            oldest_key = self.order.popleft()
            del self.cache[oldest_key]

        self.cache[key] = value
        self.order.append(key)

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

### 2回目 (OrderedDictによる解法) 
* OrderedDict Document: https://docs.python.org/ja/3/library/collections.html#collections.OrderedDict

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
        
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
    
        if len(self.cache) > self.capacity:
            self.cache.popitem(last = False)
```

### 3回目 
* cacheの中身を表示できると良いかなと思ったため、strを追加してみた。
```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def __str__(self):
        return str(self.cache)

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key) 
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            self.cache.popitem(last = False)
```

## DLLによる解法
* 下記を参照に一旦3回写経・理解しました。
参照: https://leetcode.com/problems/lru-cache/solutions/3780815/dll-map-c-java-python-beginner-friendly/
```python
class LRUCache:
    class Node:
        def __init__(self, key, val):
            self.key = key
            self.val = val
            self.previous = None
            self.next = None

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.head = self.Node(-1, -1)
        self.tail = self.Node(-1, -1)
        self.head.next = self.tail
        self.tail.previous = self.head
        self.cache = {}

    def addNode(self, new_node):
        next_node = self.head.next
        new_node.next = next_node
        new_node.previous = self.head
        self.head.next = new_node
        next_node.previous = new_node

    def deleteNode(self, node_to_delete):
        previous_node = node_to_delete.previous
        next_node = node_to_delete.next
        previous_node.next = next_node
        next_node.previous = previous_node

    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            value = node.val
            del self.cache[key]
            self.deleteNode(node)
            self.addNode(node)
            self.cache[key] = self.head.next
            return value
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            del self.cache[key]
            self.deleteNode(node)

        if len(self.cache) == self.capacity:
            oldest_key = self.tail.previous.key
            del self.cache[oldest_key]
            self.deleteNode(self.tail.previous)

        self.addNode(self.Node(key, value))
        self.cache[key] = self.head.next
```
