## Deque, OrderedDictによる解法
### 1回目 (dequeによる解法) (16m20s) 
* 問題文を読みながら書いたが、これだとputのremoveの部分で最悪計算量がO(N)になってしまう。
* OrderedDictを利用すれば良いことを知る。
* 前提として、capaictyは1以上。

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.order = deque()
        
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        else:
            self.order.remove(key)
            self.order.append(key)
            return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.order.remove(key)
            
        elif len(self.cache) == self.capacity:
            oldest_key = self.order.popleft()
            del self.cache[oldest_key]

        self.cache[key] = value
        self.order.append(key)

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

### 2回目 (OrderedDictによる解法) 
* OrderedDict Document: https://docs.python.org/ja/3/library/collections.html#collections.OrderedDict

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]
        
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
    
        if len(self.cache) > self.capacity:
            self.cache.popitem(last = False)
```

### 3回目 
* cacheの中身を表示できると良いかなと思ったため、strを追加してみた。
```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def __str__(self):
        return str(self.cache)

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key) 
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            self.cache.popitem(last = False)
```

## DLLによる解法
* 下記を参照に一旦3回写経・理解しました。
参照: https://leetcode.com/problems/lru-cache/solutions/3780815/dll-map-c-java-python-beginner-friendly/
```python
class LRUCache:
    class Node:
        def __init__(self, key, val):
            self.key = key
            self.val = val
            self.previous = None
            self.next = None

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.head = self.Node(-1, -1)
        self.tail = self.Node(-1, -1)
        self.head.next = self.tail
        self.tail.previous = self.head
        self.cache = {}

    def addNode(self, new_node):
        next_node = self.head.next
        new_node.next = next_node
        new_node.previous = self.head
        self.head.next = new_node
        next_node.previous = new_node

    def deleteNode(self, node_to_delete):
        previous_node = node_to_delete.previous
        next_node = node_to_delete.next
        previous_node.next = next_node
        next_node.previous = previous_node

    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            value = node.val
            del self.cache[key]
            self.deleteNode(node)
            self.addNode(node)
            self.cache[key] = self.head.next
            return value
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            del self.cache[key]
            self.deleteNode(node)

        if len(self.cache) == self.capacity:
            oldest_key = self.tail.previous.key
            del self.cache[oldest_key]
            self.deleteNode(self.tail.previous)

        self.addNode(self.Node(key, value))
        self.cache[key] = self.head.next
```


### 2回目
上記の理解を1回目とし、
レビュアーから頂いたコメント、他参加者のコードを参考に書き直してみる。

参照:
* https://github.com/fhiyo/leetcode/pull/9/files
* https://github.com/TORUS0818/leetcode/pull/22/files
* https://github.com/nittoco/leetcode/pull/36/files
* https://github.com/hayashi-ay/leetcode/pull/17/files

外部参照:
* LRU cache https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
* Python Doc: https://docs.python.org/ja/3/library/functools.html
* Cpython実装。

改善点:
* head, tailをsentinelとして、先頭ノード、末尾を指してノードを一つに変更。
* addNodeの関数名が分かりづらい(順番を保つために先頭にノードを加える性質が)ため、insert_frontに変更。
* get関数にて、keyがcacheに存在していない場合、早期リターン。(可読性)
* 変数名の調整。
* Node classのデフォルトバリューの定義。

```python
class LRUCache:
    class Node:
        def __init__(self, key = None, value = None, next = None, previous = None):
            self.key = key
            self.value = value
            self.next = next
            self.previous = previous

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.sentinel = self.Node(None, -1)
        self.sentinel.next = self.sentinel
        self.sentinel.previous = self.sentinel

    def insert_front(self, node):
        self.cache[node.key] = node
        next_node = self.sentinel.next
        node.next = next_node
        next_node.previous = node
        self.sentinel.next = node
        node.previous = self.sentinel

    def delete_node(self, node):
        del self.cache[node.key]
        next_node = node.next
        previous_node = node.previous
        next_node.previous = previous_node
        previous_node.next = next_node

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self.delete_node(node)
        self.insert_front(node)
        return node.value
        
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.delete_node(self.cache[key])

        node = self.Node(key, value)
        self.insert_front(node)
        
        if len(self.cache) > self.capacity:
            oldest_key = self.sentinel.previous.key
            self.delete_node(self.cache[oldest_key])
```

* Nodeクラスは別で持たせた方が見やすいと思ったため変更。
* サイズ変数を導入

### 3回目
```python
class Node:
    def __init__(self, key = None, value = None, previous = None, next = None):
        self.key = key
        self.value = value
        self.previous = previous
        self.next = next

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.size = 0
        self.sentinel = Node(None, -1)
        self.sentinel.next = self.sentinel
        self.sentinel.previous = self.sentinel

    def insert_front(self, node):
        self.cache[node.key] = node
        self.size += 1
        next_node = self.sentinel.next
        self.sentinel.next = node
        node.previous = self.sentinel
        node.next = next_node
        next_node.previous = node

    def delete_node(self, node):
        del self.cache[node.key]
        self.size -= 1
        previous_node = node.previous
        next_node = node.next
        previous_node.next = next_node
        next_node.previous = previous_node
    
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self.delete_node(node)
        self.insert_front(node)
        return node.value
        
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.delete_node(self.cache[key])

        node = Node(key, value)
        self.insert_front(node)
        
        if self.size > self.capacity:
            oldest_key = self.sentinel.previous.key
            self.delete_node(self.cache[oldest_key])
```


## DLL別実装による解法
```python
class Node:
    def __init__(self, key = None, value = None, previous = None, next = None):
        self.key = key
        self.value = value
        self.previous = previous
        self.next = next

class DoubledLinkedList:
    def __init__(self):
        self.head = Node(None, -1)
        self.tail = Node(None, -1)
        self.head.next = self.tail
        self.tail.previous = self.head
        self.size = 0

    def insert_front(self, node):
        next_node = self.head.next
        node.next = next_node
        node.previous = self.head
        next_node.previous = node
        self.head.next = node
        self.size += 1
    
    def delete_node(self, node):
        previous_node = node.previous
        next_node = node.next
        previous_node.next = next_node
        next_node.previous = previous_node
        self.size -= 1
        
class LRUCache:
    def __init__(self, capacity: int):
        self.cache = {}
        self.capacity = capacity
        self.linked_list = DoubledLinkedList()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1

        node = self.cache[key]
        self.linked_list.delete_node(node)
        self.linked_list.insert_front(node)

        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.linked_list.delete_node(self.cache[key])
            del self.cache[key]
        
        node = Node(key, value)
        self.cache[key] = node
        self.linked_list.insert_front(node)

        if self.linked_list.size > self.capacity:
            oldest_key = self.linked_list.tail.previous.key
            self.linked_list.delete_node(self.cache[oldest_key])
            del self.cache[oldest_key]

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```




