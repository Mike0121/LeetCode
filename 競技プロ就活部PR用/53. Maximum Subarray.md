参照:
https://github.com/olsen-blue/Arai60/pull/32/files
https://leetcode.com/problems/maximum-subarray/description/
https://github.com/hroc135/leetcode/pull/30
https://github.com/TORUS0818/leetcode/pull/34/files
https://github.com/Ryotaro25/leetcode_first60/pull/35/files
https://github.com/fhiyo/leetcode/pull/33/files
https://github.com/goto-untrapped/Arai60/pull/30
https://github.com/YukiMichishita/LeetCode/pull/13
https://github.com/SuperHotDogCat/coding-interview/pull/14/files
https://github.com/hayashi-ay/leetcode/pull/36/files

https://discord.com/channels/1084280443945353267/1206101582861697046/1208414507735453747


## Overview
* 入力の例外を考えると、numsが空のケース

# Kadane's Algorithm
* 時間計算量: O(N)
* 空間計算量: O(1)
### 1回目 (6m25s, sumの更新式をsum = nにしており1回エラーを出した。)
* 以前に同じくKadane's Algorithmを解いていたため、解法⇨コード自体は比較的すぐ思いついた。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        subarray_sum = 0
        max_subarray_sum = nums[0]

        for n in nums:
            subarray_sum += n
            max_subarray_sum = max(subarray_sum, max_subarray_sum)

            if subarray_sum < 0:
                subarray_sum = 0

        return max_subarray_sum
```

### 2回目
* 余計なif文を削除できる。
* max()で比較を行う際、どちら側を左右に書くかは自分の中で曖昧。
* 変数名、subarray_sum以外にもcurrent_sum, sum_so_far, でも良さそう。
* subarray_sum = 0, max_subarray_sum = -float('inf')で初期化してループを0から始めても良い。その場合、可読性は高いかもしれないがfloat -> intの型変換が起こるため自分ははこちらを採用。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        subarray_sum = nums[0]
        max_subarray_sum = nums[0]

        for i in range(1, len(nums)):
            subarray_sum = max(nums[i], subarray_sum + nums[i])
            max_subarray_sum = max(subarray_sum, max_subarray_sum)

        return max_subarray_sum
```

### 3回目
* whileでも書き換えてみる。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        subarray_sum = nums[0]
        max_subarray_sum = nums[0]
        end = 1

        while end < len(nums):
            subarray_sum = max(nums[end], subarray_sum + nums[end])
            max_subarray_sum = max(subarray_sum, max_subarray_sum)

            end += 1

        return max_subarray_sum
```


## 累積和による解法 
* 時間計算量: O(N)
* 空間計算量: O(1)

### 1回目
```
ロジック整理:
min_cumulative_sum: これまでの累積和の中で最小の値
ある区間まででの累積和 (cumulative_sum) から、区間開始直前までの最小の累積和 (min_cumulative_sum)を引くことで、
ある区間の部分和を求める。その区間の部分和(max_sum)が最大となるものを採用。
ここで、


nums = [1, 2, 3]の場合
cumulative_sum:     0 1 2 6
max_sum:         -inf 1 2 6
min_cumulative_sum: 0 0 0 0


nums = [1, -3, -3, 4]の場合
cumulative_sum:     0 1 -2 -5 -1
max_sum:         -inf 1  1  1  1
min_cumulative_sum: 0 0 -2 -5 -5


下記もわかりやすい。(c.f.: https://github.com/olsen-blue/Arai60/pull/32/files)
【遷移式の理解】
・遷移式は下記 :
new_標高差 = max(num, old_標高差 + num)

下記の①②のうち、大きくなる方を max() で採用する。
① num を採用するとき :
old_標高差が負になった時、つまり直前が最深谷(ボトム基準)に更新された場合。
直前を新たな最深谷(ボトム基準)に設定するので、0 + num となる。

② old_標高差 + num を採用する時 :
old_標高差が正になった時、つまり直前で最深谷(ボトム基準)の更新がなかった場合。
直前の標高差を引き継いで現在の標高差を計算するので、old_標高差 + num となる。
```

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        cumulative_sum = 0
        min_cumulative_sum = 0 
        max_sum = -math.inf

        for i in range(len(nums)):
            cumulative_sum += nums[i]
            max_sum = max(max_sum, cumulative_sum - min_cumulative_sum)
            min_cumulative_sum = min(min_cumulative_sum, cumulative_sum)

        return max_sum
```

### 2回目
* 更新の順番を並び替えた。個人的にこっちの方がわかりやすい。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum = nums[0]
        cumulative_sum = 0
        min_cumulative_sum = 0
        for i in range(len(nums)):
            min_cumulative_sum = min(cumulative_sum, min_cumulative_sum)
            cumulative_sum += nums[i]
            max_sum = max(max_sum, cumulative_sum - min_cumulative_sum)

        return max_sum
```

### 3回目
* コメントを参照に1変数にまとめる。https://github.com/sakupan102/arai60-practice/pull/33/files#r1611415355
* cumulative -> prefixに変更。

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        prefix_sum = 0  
        min_prefix_sum = 0
        max_sum = -math.inf

        for num in nums:
            old_prefix_sum = prefix_sum
            old_min_prefix_sum = min_prefix_sum

            new_prefix_sum = old_prefix_sum + num
            new_min_prefix_sum = min(old_min_prefix_sum, old_prefix_sum)
            
            candidate = new_prefix_sum - new_min_prefix_sum
            candidate_equiv = num + max(old_prefix_sum - old_min_prefix_sum, 0)

            max_sum = max(max_sum, candidate)
            
            prefix_sum = new_prefix_sum
            min_prefix_sum = new_min_prefix_sum

        return max_sum
```


## 分割統治法 (45m)
* 参照: https://github.com/hayashi-ay/leetcode/pull/36/files (慣れているので2つの関数にする形で実装。)
* 時間計算量: O(NlogN) 
* 空間計算量: O(1)

* 3回書いてみて、まだ理解できていない。
  1. 分割 -> 統治の流れはわかるが、何をreturnとして返せば良いか。if left == right:の場合の返却値 (return nums[0]と書いていて)でエラーを出した。
  2. 特に実際に面接で聞かれた際、コードを頭の中で追い切れる自信がない。
* 関数名にやや違和感を感じる。
* left, rightはindexであることを変数名に明記しても良い。(少し長い。)
* right_sum_max = -float('inf')の初期化はleft_sum_maxと同じ箇所にしていたが参照の直前に移動。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        def find_max_devide_and_conquer(left: int, right: int) -> int:
            if left == right:
                return nums[left]

            mid = (left + right) // 2
            left_sum_max = find_max_devide_and_conquer(left, mid)
            right_sum_max = find_max_devide_and_conquer(mid + 1, right)
            all_sum_max = find_max_crossing_subarray(nums, left, mid, right)

            return max(left_sum_max, right_sum_max, all_sum_max)

        def find_max_crossing_subarray(arr: List[int], left: int, mid: int, right: int) -> int:
            left_sum_max = -float('inf')
            subarray_sum = 0

            for i in range(mid, left - 1, -1):
                subarray_sum += arr[i]
                left_sum_max = max(subarray_sum, left_sum_max)

            right_sum_max = -float('inf')
            subarray_sum = 0

            for i in range(mid + 1, right + 1):
                subarray_sum += arr[i]
                right_sum_max = max(subarray_sum, right_sum_max)

            return left_sum_max + right_sum_max

        return find_max_devide_and_conquer(0, len(nums) - 1)
```

## 全探索による解法 (TLE)
* 時間計算量: O(N^2)
* 空間計算量: O(1)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_total = nums[0]
        for i in range(len(nums)):
            sub_total = 0
            for j in range(i, len(nums)):
                sub_total += nums[j]
                max_total = max(max_total, sub_total)

        return max_total
```


