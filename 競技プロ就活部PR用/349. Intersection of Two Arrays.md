Note
問題を見て思いついた解法は、
1. setによる&(intersection)
2. setの演算子を利用せずにfor文で回す方　の2つ。<br>
これに加えて、
LeetcodeのDiscussionでBinary Searchを使っても解けること、
Odaさんのコメントからtwo-pointerの解き方もできると考えたので追記。

setからlistへの計算量は、O(N)。
この問題の実際の最適解は、setへの変換を行うべきか、すなはちどの程度listが重複した値を含むかを想定するかで分かれると感じた。


## Setの演算による解法 ★
### 1回目 (1m23s)
時間計算量: O(n) + O(m) + O(min(n, m))<br>
空間計算量: O(n + m + min(n, m))<br>
n: len(n), m: len(m)

> https://docs.python.org/ja/3/library/stdtypes.html#set
>
> ```python return set(nums1).intersection(set(nums2))```でも良い。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return set(nums1) & set(nums2)
```

## Setの演算子を利用しない解法　★
### 1回目
時間計算量: O(n + m + m)<br>
空間計算量: O(n + m)<br> 
n: len(n), m: len(m)

> nums1, nums2のいずれかに重複を多く含んでいた場合を考慮し、一旦両方をsetに変換。
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:             
        unique_nums1 = set(nums1)
        unique_nums2 = set(nums2)

        common_nums = []
        for num2 in unique_nums2:
            if num2 in unique_nums1:
                common_nums.append(num2)
        return common_nums
```

### 2回目
時間計算量: O(n + m + *min(n, m)*)<br>
空間計算量: O(n + m + min(n, m))<br> 
n: len(n), m: len(m)

> fhiyoさんのコードを参考に、短い方をsetに変換して回す。
> わずかだが計算量を改善できる。
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        smaller = set(nums1)
        larger = set(nums2)
        if len(smaller) > len(larger):
            smaller, larger = larger, smaller

        common_nums = []
        for num in smaller:
            if num in larger:
                common_nums.append(num)

        return common_nums
 ```


## two-pointerによる解法 (双方を sorted にしてマージソートっぽく。) ★
時間計算量: O(nlogn + mlogm + min(n, m))<br>
空間計算量: O(n + m + min(n, m))<br>
n: len(n), m: len(m)

> nums1 = [nan], nums2 = [nan]の場合の無限ループを防ぐ。
> 
> nanの挙動に関する参照:
- https://pystyle.info/floating-point-numbers/
- https://zehnpaard.hatenablog.com/entry/2022/05/30/084212
- 
> if - elif - elseでかき分けて、setに追加していく書き方でも良いかと思った。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        for num in nums1 + nums2:
            if isnan(num):
                raise RuntimeError('nan Value Error')
        sorted_nums1 = sorted(nums1)
        sorted_nums2 = sorted(nums2)
        index1 = 0
        index2 = 0
        common_nums = []

        while index1 < len(sorted_nums1) and index2 < len(sorted_nums2):
            if sorted_nums1[index1] < sorted_nums2[index2]:
                index1 += 1
                continue
            if sorted_nums2[index2] < sorted_nums1[index1]:
                index2 += 1
                continue
        
            num = sorted_nums1[index1]
            common_nums.append(num)

            while index1 < len(sorted_nums1) and sorted_nums1[index1] == num:
                index1 += 1
            while index2 < len(sorted_nums2) and sorted_nums2[index2] == num:
                index2 += 1

        return common_nums
```


## Dictを利用した解法(片方を、dictかsetにする。)
### 1回目
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:             
        common_num_counter = {}
        for num1 in nums1:
            common_num_counter[num1] = 0

        for num2 in nums2:
            if num2 in common_num_counter:
                common_num_counter[num2] += 1
                
        common_nums = []
        for common_num, appear_count in common_num_counter.items():
            if appear_count > 0:
                common_nums.append(common_num)

        return common_nums
```

### 2回目
> dictのvalueがintである必要はないため、booleanに変更。
> common_numsをsetに変更。
> 1回目の解法は余計にnums2を回しているため、削除してdictで検索。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        num_dict = {num: True for num in nums1}
        common_nums = set()

        for num in nums2:
            if num in num_dict:
                common_nums.add(num)

        return list(common_nums)
```


## Bisectを利用した解法 ★
時間計算量: O(n + m) + O(mlogm) + O(nlogm)<br>
空間計算量: O(n + m + m + min(n, m))<br>
n: len(n), m: len(m)

sortを利用せずに、
```python num1 in unique_nums2```とした方が良いか。
LeetCodeのディスカッションにあり、試しに書いてみたがあまりメリットはなさそう。
強いて言えば、listが事前にsortされている場合に有効か。

```python
unique_nums1= set(nums1)
unique_nums2 = set(nums2)
sorted_unique_nums2 = sorted(unique_nums2)

common_nums = []

for num1 in unique_nums1:
    index = bisect.bisect_left(sorted_unique_nums2, num1)

    if index < len(sorted_unique_nums2) and num1 == sorted_unique_nums2[index]:
        common_nums.append(num1)

return common_nums
```
