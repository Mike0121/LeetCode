## 再帰による解法
---
時間計算量: O(2^N)<br>
空間計算量: O(2^N)<br>

入れ替えるのは0→"01", 1→"10"を同時に入れ替える良い方法が思いつかず、
関数を実装した。愚直に再帰で解く方法は5分程度で書けたが、TLEだった。法則性などを見つける必要があるかと考える。

### 0回目 (TLE)
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        def replace_row(num_string):
            result_num = ""
            for num in num_string:
                if num == "0":
                    result_num += "01"
                if num == "1":
                    result_num += "10"
            return result_num

        def create_nth_row(row, nth_row):
            if row == n:
                return nth_row

            nth_row = replace_row(nth_row)

            return create_nth_row(row + 1, nth_row)
            
        final_row = create_nth_row(1, "0")
        return int(final_row[k-1])
```

## 再帰(木構造の利用)による解法 
---
時間計算量: O(N)<br>
空間計算量: O(N)<br>

Leetcodeのディスカッションを基に、木構造を模していることがわかり、
親ノードの情報と反転をもとに書いた。

### 1回目
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0

        parent_node = self.kthGrammar(n - 1, (k + 1) // 2)
        
        if parent_node == 0:
            if k % 2 == 1: 
                return 0
            else:
                return 1

        elif parent_node == 1:
            if k % 2 == 1: 
                return 1
            else:
                return 0
```

parent_nodeは、今回問題文で木が定義されているわけではないためprevious_symbolに変更。
対称性(0or1)のため、if-elseに変更

### 2~3回目
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if n == 1:
            return 0

        previous_symbol = self.kthGrammar(n - 1, (k + 1) // 2)

        if previous_symbol == 0:
            if k % 2 == 1:
                return 0
            else:
                return 1

        else:
            if k % 2 == 1:
                return 1
            else:
                return 0
```

### 4回目
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        if k == 1:
            return 0

        previous_symbol = self.kthGrammar(n - 1, (k + 1) // 2)

        if k % 2 == 0:
            return 1 - previous_symbol
        else:
            return previous_symbol
```

## bit演算による解法
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        k -= 1
        
        count = 0
        while k > 0:
            count += k & 1
            k >>= 1
        
        return count % 2
```


## int.bit_countによる解法 (https://docs.python.org/3/library/stdtypes.html#int.bit_count)
---
```python
class Solution:
    def kthGrammar(self, n: int, k: int) -> int:
        return (k - 1).bit_count() % 2
```
