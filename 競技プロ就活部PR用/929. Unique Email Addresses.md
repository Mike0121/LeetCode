> Note:
> 自身で思いついた解法は、1.標準ライブラリを利用した解法 2.indexによる文字列チェックの関数化 3.正規表現による解法
> 問題文による制限がかなり強いため、楽になっていると感じた。ぱっとおもいつくのは、各コードに@の出現回数が1回の場合の例外処理を書く。
```python
if len(email).split != 2:
    raise Exception('Invalid Email Input')
```

## 標準ライブラリを利用した解法
### 1回目 (5m34s)
時間計算量: O(N*M)<br>
空間計算量: O(N)<br>
N: len(emails), M: len(local_name)

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()

        for email in emails:
            local_name = email.split("@")[0].replace(".", "").split("+")[0]
            domain_name = email.split("@")[1]
            unique_emails.add(local_name + "@" + domain_name)
        return len(unique_emails)
```


### 2回目
時間計算量: 1回目と同じ<br>
空間計算量: 1回目と同じ<br>

> 問題の制限から、emailは**1つの**@まで区切られているので、
> ```pyhton local_name, domain_name = email.split("@")```と1行に変更。
> 上記に合わせて、1行での読み取りの負荷を減らすために、replaced_local_nameを中間変数として作成。
> unique_emailsは、文字列の結合を行わずとも、タプルとして入れても良いかと思った。
> ちょっと変数名が長い気がした。_nameを削除。


```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()

        for email in emails:
            local, domain = email.split("@")
            formatted_local = local.replace(".", "").split("+")[0]
            unique_emails.add(formatted_local + domain)
        return len(unique_emails)
```


## indexによる文字列チェックの関数化
時間計算量: O(N*M)<br>
空間計算量: O(N)<br>
N: len(emails), M: len(local_name)

> ahayashiさんのコードの様に、localとdomainを分けず、'@'を処理に加えても良いも。

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        def format_local_address(oroginal_local: str) -> str:
            i = 0
            replaced_local = ""
            while i < len(oroginal_local) and oroginal_local[i] != '+':
                if oroginal_local[i] != '.':
                    replaced_local += oroginal_local[i]
                i += 1
            return replaced_local
        
        unique_emails = set()

        for email in emails:
            local, domain = email.split("@")
            formatted_local = format_local_address(local)
            unique_emails.add(formatted_local + "@" + domain)

        return len(unique_emails)
```

## 正規表現による解法
時間計算量: O(N*M)<br>
空間計算量: O(N)<br>
N: len(emails), M: len(local_name)

```python
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()

        for email in emails:
            local, domain = email.split("@")
            formatted_local = re.sub(r'\.+', '', local)
            formatted_local = re.sub(r'\+.*', '', formatted_local)
            unique_emails.add(formatted_local + domain)

        return len(unique_emails)
```
