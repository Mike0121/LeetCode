問題文の、root-to-leafを読み飛ばしており、[1, 2] targetSum=1　(Expected Output: False)の場合のテストケース
が通らず、20分程度費やした挙句、1回目のコードがかなり歪な形にある。

### 1回目
- 時間計算量: O(N) (すべてのノードを1度ずつ通過)
- 空間計算量: O(N)

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def hasPathSum_sub(node, target):
            if not node:
                return False
            
            target = target - node.val
            
            if node.left == None and node.right == None:
                if target == 0:
                    return True
                else:
                    return False

            left_result = hasPathSum_sub(node.left, target)
            right_result = hasPathSum_sub(node.right, target)

            return left_result or right_result

        return hasPathSum_sub(root, targetSum)
```

### 2回目
- 時間計算量: 1回目と同じ
- 空間計算量: 1回目と同じ

 ```python
 class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
		 if not root:
		    return False

        current_taget = targetSum - root.val
        
        if root.left == None and root.right== None:
            if current_taget == 0:
                return True
            else:
            	return False

        left_result = self.hasPathSum(root.left, current_target)
        right_result = self.hasPathSum(root.right, current_target)

        return left_result or right_result
```            

current_targetが不要、left, right_reusltも不要であることを@ahayashiさんのコードから気が付く。<br>
ただ、reuturn文が少し横長になり過ぎてしまうので、その場合はleft_result, right_resultのように変数を立てるのをを検討しても良いかと思った。

### 3回目
- 時間計算量: 1回目と同じ
- 空間計算量: 1回目と同じ
```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        
        if not root.right and not root.left:
            if root.val == targetSum:
                return True
        
        return self.hasPathSum(root.left, targetSum - root.val) or  self.hasPathSum(root.right, targetSum - root.val)
```

### スタックによる解法
- 時間計算量: 1回目と同じ
- 空間計算量: 1回目と同じ


stackの名前をはじめはpath_stackにしていましたが、実際に保存されているのはnodeのため、node_stackに変更しました。
nodesとかでもいいかもと思いました。

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        node_stack = [(root, targetSum)]

        while node_stack:
            node, target = node_stack.pop()
            if not node:
                continue
            if not node.left and not node.right:
                if target == node.val:
                    return True
            
            node_stack.append((node.left, target - node.val))
            node_stack.append((node.right, target - node.val))

        return False
```
