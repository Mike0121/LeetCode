
はじめに、2つのsubtreeを作るために、(i)rootからsubtreeを引き算する方法 (ii)rootから見ていって、値に応じてそれぞれのsubtreeを作る方法
を検討して、(ii)の方が描きやすいと考えた。また、値を順々に見ていくために、BFSの方が良いと考えたが、今回はDFSの方が適切(考えやすい)だった模様。
いずれの解法にせよ取り出すsubtreeを作成する方法はわかったが、その後どのようにrootからsubtreeを消すかが思いつかなかった。

### 0回目
```python
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if not root:
            return [None, None]

        nodes = deque([root])

        while nodes:
            node = nodes.popleft()

            if node.val <= target:
                subtree_root1 = TreeNode(node.val)
                subtree_root1.left = node.left
            else:
                subtree_root2 = TreeNode(node.val)
                ###ここでどのように分岐させるべきかがわからなかった。###

            if node.right: nodes.append(node.right)
            if node.left: nodes.append(node.left)


        return [subtree_root1, subtree_root2]
  ```


 ### 1回目 (解答を見てから書き直し)
時間計算量: O(N) (ツリーが偏っている場合。CompleteなBSTであればO(logN))<br>
空間計算量: O(1) (ポインタの変更のみ)<br>
 
```python
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if root is None:
            return [None, None]

        if root.val <= target:
            smaller, larger = self.splitBST(root.right, target)
            root.right = smaller
            return [root, larger]

        smaller, larger = self.splitBST(root.left, target)
        root.left = larger
        return [smaller, root]
```


### 2回目
時間計算量: 1回目と同じ <br>
空間計算量: 1回目と同じ <br>

```python
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if not root:
            return [None, None]
        
        if root.val <= target:
            left, right = self.splitBST(root.right, target)
            root.right = left
            return [root, right]


        else:
            left, right =  self.splitBST(root.left, target)
            root.left = right
            return [left, root]
```

### 3回目
時間計算量: 1回目と同じ <br>
空間計算量: 1回目と同じ <br> 

```python
class Solution:
    def splitBST(self, root: Optional[TreeNode], target: int) -> List[Optional[TreeNode]]:
        if not root:
            return [None, None]

        if root.val <= target:
            left, right = self.splitBST(root.right, target)
            root.right = left
            return [root, right]
        
        else:
            left, right = self.splitBST(root.left, target)
            root.left = right
            return [left, root]
```
