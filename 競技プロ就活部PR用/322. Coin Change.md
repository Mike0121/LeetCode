
### 参照:
https://github.com/Satorien/LeetCode/pull/40
https://github.com/TORUS0818/leetcode/pull/42
https://github.com/nittoco/leetcode/pull/38
https://github.com/Yoshiki-Iwasa/Arai60/pull/54
https://github.com/fhiyo/leetcode/pull/41
https://github.com/goto-untrapped/Arai60/pull/34/files
https://github.com/sakupan102/arai60-practice/pull/41
https://github.com/Satorien/LeetCode/pull/40
https://github.com/potrue/leetcode/pull/40
https://github.com/tokuhirat/LeetCode/pull/40
https://github.com/Fuminiton/LeetCode/pull/40
https://github.com/hroc135/leetcode/pull/38

### 想定テストケース: (今回は詳細はスキップ)
1. 正常系: 短縮なし
amount: 6
coins: [1]
想定出力: 1

2. 正常系: 短縮あり
amount: 6
coins: [1, 2, 3]
想定出力: 2

3. 正常系: 正解なし
amount: 0
coins: [1]
想定出力: -1

4. 正常系: 計算量最大
amount: 10^4
coins: [1]
想定出力: 10^4

5. 例外系: amountが負の値の場合
amount: -1
coins: [1, 2, 3]
想定出力: raise ValueError("amount must not be a negative value.")

6. 例外系: coinsが空の場合
amount: 100
coins: []
想定出力: raise ValueError("coins must not be empty.")

7. 例外系; coinsが負の値を含む場合
amount: 100
coins: [-1, 1]
想定出力: raise ValueError("coins must not contain any negative values.")



## DPによる解法
* 時間計算量: O(M * N)
* 空間計算量: O(M) (dpテーブル分)
M: amount, N: coinsの長さ

### 1回目 (5m21s)
* とりあえず通るコード。下記3点が個人的に感じたディスカッションポイント。
* 変数名, "現在注目している作りたい金額" をどのように変数名にするかは結構悩んだ。
* dpテーブル: min_num_of_coinをfloat('inf')で初期化しているが、型が異なるのが違和感ある。
* value - coin >= 0のみの場合に更新するという書き方でも良い。(好み？)個人的には下記の書き方が好み。

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        min_num_of_coins = [float('inf')] * (amount + 1)
        min_num_of_coins[0] = 0

        for value in range(amount + 1):
            for coin in coins:
                if value - coin < 0:
                    continue
                
                min_num_of_coins[value] = min(min_num_of_coins[value - coin] + 1, min_num_of_coins[value])

        return min_num_of_coins[-1] if min_num_of_coins[-1] != float('inf') else -1
```


### 2回目
* "現在注目している作りたい金額" の変数名は他のPRから下記のようなものがあった。結構色々あるところを見ると難しいと感じた。valueのままで個人的には良いと感じた。
remaining, current_amount, money, 関数の引数名をtarget_amountに変更, total
* if分岐をcontinueではなく条件を満たした場合のみ間更新する形にした。continueの方が好み。
* min_num_of_coinsを`10**4 + 1`で初期化。ただしこの値はシステム的なバックグラウンドを確認。(変更頻度、他変数との関係性など)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        MAX_INT = 10 ** 4 + 1
        min_num_of_coins = [MAX_INT] * (amount + 1)
        min_num_of_coins[0] = 0

        for value in range(amount + 1):
            for coin in coins:
                if value - coin >= 0:
                    min_num_of_coins[value] = min(
                        min_num_of_coins[value - coin] + 1,
                        min_num_of_coins[value]
                    )

        return -1 if min_num_of_coins[-1] == MAX_INT else min_num_of_coins[-1]
```


### 3回目
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        MAX_INT = 10 ** 4 + 1
        min_num_of_coins = [MAX_INT] * (amount + 1)
        min_num_of_coins[0] = 0

        for value in range(amount + 1):
            for coin in coins:
                if value - coin < 0:
                    continue
                
                min_num_of_coins[value] = min(
                    min_num_of_coins[value - coin] + 1,
                    min_num_of_coins[value]
                )

        return -1 if min_num_of_coins[-1] == MAX_INT else min_num_of_coins[-1]
```

## BFS(ダイクストラ)による解法
* 時間計算量: O(M * N * logM) (ヒープ操作分、log M が入る)
* 空間計算量: O(M * N)
M: amount, N: coinsの長さ

```Note
1. 各金額をノード、コイン1枚使う操作を「重み1の辺」とする。
2. 0 から amount までの最短距離(=最小コイン枚数)を、優先度付きキュー（ヒープ）で探索して求める。
3. visitedは不要な再探索を避けるため、amountが小さければなくてもOOMは発生しない。
```

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0

        pq = [(0, 0)]
        visited = set()

        while pq:
            num_coins, value = heapq.heappop(pq)

            if value == amount:
                return num_coins
            if value in visited:
                continue
            visited.add(value)

            for coin in coins:
                next_value = value + coin
                if next_value <= amount:
                    heapq.heappush(pq, (num_coins + 1, next_value))    
            
        return -1
```
