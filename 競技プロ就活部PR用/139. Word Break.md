### 問題全体:
- wordDict or s が空の場合が例外ケース
- 大文字が混在する場合はチェック。(関数が全てlower case想定のため)

### 想定テストケース:
1. 正常系 (正解あり)
s = "leetcode", wordDict = ["leet", "code"]
-> 想定Output: True

2. 正常系 (正解なし)
s = "leetcode", wordDict = ["leet", "dog"]
-> 想定Output: False

3. 正常系 (計算量最大)
s = "aaaaaaaa..aaa" (長さ300), wordDict = ["a", "aa", "aaa", ...]  (長さ1,000)
-> 想定Output: True

4. 例外
s = "", wordDict = ["leet", "code"]
-> 想定Output: Error

5. 例外
s = "leetcode", wordDcit = []
-> 想定Output: Error

6. 例外
s = "LEETCODE", wordDict = ["leet", "code"]
-> 想定Output: False (このケースを通すには別途処理が必要)


## DFSによる解法
* 時間計算量: O(N^3 + M*k) (len(s): N, len(WordDict): M, 平均のWordの長さ: k)
* 空間計算量: O(M * k) (visited分) + O(N) (スタック領域に再帰分)

### 1回目 (12m24s, エラー3回)
* 1番最初に思い浮かんだのはDPよりもDFS, BFSでsを作っていく方法 
* 最終的な結果をどのようにもつかを悩み(return or 変数としてもつ)かで2回エラーを出した。
  -> これに関してはより確実な方法をとればよかった。
* visitedを用意せずにTLEを1回出した。
* 最大の再帰の深さの計算してみる。
  visitedを用意しない場合: O(len(s))-> 最大300回 
  pythonのdefualt最大recursion回数: 1,000 (変更: https://docs.python.org/ja/3/library/sys.html#sys.setrecursionlimit)

簡易復習事項:
* なぜ selfが必要か？
  -> Pythonでは関数内で動作する変数は関数の中でのみ動くローカル変数のため。クラス変数として同じ変数にアクセスする必要がある。
* なぜ、substring += wordではいけないか？
  -> substringオブジェクト自体が更新されてしまうから別の新しいオブジェクトを作成する必要がある。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        self.is_segmented = False
        visited = set()

        def check_is_segmented(substring: str) -> bool:
            if substring == s:
                self.is_segmented = True

            for word in wordDict:
                next_substring = substring + word
                if next_substring == s[:len(next_substring)] and next_substring not in visited:
                    visited.add(next_substring)
                    check_is_segmented(next_substring)

            return
        
        check_is_segmented("")
        return self.is_segmented
```


### 2回目
* 1回目で大まかに修正を行なったため、変更はなし

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        self.is_segmented = False
        visited = set()

        def check_is_segmented(substring: str) -> bool:
            if substring == s:
                self.is_segmented = True

            for word in wordDict:
                next_substring = substring + word
                if next_substring == s[:len(next_substring)] and next_substring not in visited:
                    visited.add(next_substring)
                    check_is_segmented(next_substring)

        check_is_segmented("")
        return self.is_segmented
```


### 3回目
* @lru_cacheを使っても通ることを確認
* この場合lru_cacheには以前に計算済みの関数の結果が入る。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        self.is_segmented = False
        @lru_cache
        def check_is_segmented(substring: str) -> bool:
            if substring == s:
                self.is_segmented = True

            for word in wordDict:
                next_substring = substring + word
                if next_substring == s[:len(next_substring)]:
                    check_is_segmented(next_substring)

        check_is_segmented("")
        return self.is_segmented
```

## BFSによる解法
* 時間計算量: O(N^3 + M*k) (len(s): N, len(WordDict): M, 平均のWordの長さ: k)
* 空間計算量: O(M * k) (visited分) + O(N) (スタック領域に再帰分)

### 1回目
* DFSと同様に直接substringを構成していく方法でも解ける。
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        queue = deque([0])
        visited = set()
        
        while queue:
            start_index = queue.popleft()
            if start_index >= len(s):
                return True
            
            for word in wordDict:
                if start_index + len(word) <= len(s) and word == s[start_index:start_index+len(word)] and start_index + len(word) not in visited:
                    queue.append(start_index + len(word))
                    visited.add(start_index + len(word))

        return False
```

### 2回目
* if文が長かった(79文字以上 PEP8 https://pep8-ja.readthedocs.io/ja/latest/#id8)だったので別の変数の作成と改行を入れた。
* queueの命名をよりわかりやすいものに変更。
* if文は別の関数を用意するのも手であると考える。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        next_start_indexes = deque([0])
        visited = set()
        
        while next_start_indexes:
            start_index = next_start_indexes.popleft()
            if start_index >= len(s):
                return True
            
            for word in wordDict:
                next_index = start_index + len(word)
                if next_index <= len(s) and \
                word == s[start_index:next_index] and \
                next_index not in visited:
                    next_start_indexes.append(next_index)
                    visited.add(next_index)

        return False
```

### 3回目
* indexではなくsubstringを生成していく方法。
* 空間計算量は文字列が大きすぎなければ影響はないと考えると、こちらの方がわかりやすくて好み。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        next_words = deque()
        visited = set()

        for word in wordDict:
            if word == s[:len(word)]:
                next_words.append(word)

        while next_words:
            substring = next_words.popleft()
            if substring == s:
                return True
            
            for word in wordDict:
                next_substring = substring + word
                if next_substring == s[:len(next_substring)] and next_substring not in visited:
                    next_words.append(next_substring)
                    visited.add(next_substring)

        return False
```


## DPによる解法 (8m30s)
* 時間計算量: O(N*M*k)
* 空間計算量: O(N)

* i:i + len(word), i - len(word):iのどちらをチェックしても良いが、好みの問題か。
* その他、逆順でチェックしてく方法もある。
* 下記の点に注意すれば、if文を2つに分けなくても、最初のif文で
* word_segmented[i]がFalseでも最初のifを通過する可能性があるため、word_segmented[i]がTrueの場合のみbreakしている。
 (s = "abcd", wordDict = ["cd"]の場合、cdが一致するのでabまでがFalseでも最初のifは追加する。)

### 1回目
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word_segmented = [False] * (len(s) + 1)
        word_segmented[0] = True

        for i in range(1, len(s) + 1):
            for word in wordDict:
                if i - len(word) >= 0 and word == s[i-len(word):i]:
                    word_segmented[i] = word_segmented[i-len(word)]
                
                if word_segmented[i] == True: 
                    break

        return word_segmented[-1]
```

### 2回目
* if文を1つにまとめる。

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word_segmented = [False] * (len(s) + 1)
        word_segmented[0] = True

        for i in range(1, len(s) + 1):
            for word in wordDict:
                if i - len(word) >= 0 and \
                word == s[i-len(word):i] \
                and word_segmented[i-len(word)]:
                    word_segmented[i] = word_segmented[i-len(word)]

        return word_segmented[-1]
```

### 3回目
* 変更なし

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        word_segmented = [False] * (len(s) + 1)
        word_segmented[0] = True

        for i in range(1, len(s) + 1):
            for word in wordDict:
                if i - len(word) >= 0 and \
                word == s[i-len(word):i] \
                and word_segmented[i-len(word)]:
                    word_segmented[i] = word_segmented[i-len(word)]

        return word_segmented[-1]
```

* トライ木の実装
今回はスキップ


### 4回目
* 作成中の文字列とsの一致判定をstartswithに変更 (参考: https://docs.python.org/ja/3.13/library/stdtypes.html)
* is_segmentedの更新をnon localを利用し参照透過に変更 (cf: https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7)
* check_is_segmentedの関数の返り値をNoneに変更

参照透過性:
```
ある式が参照透過であるとは、その式をその式の値に置き換えてもプログラムの振る舞いが変わらない(言い換えれば、同じ入力に対して同じ作用と同じ出力とを持つプログラムになる)ことを言う。
-> 関数に同じ引数を与えたら、常に同じ結果が返る性質
-> 参照透過性が満たされないと、self.is_segmented のように共有変数は、複数のスレッドが同時にアクセス・変更すると、予期しない動作（race condition）が発生する可能性がある。
```

参照透過の例:
```python
def add(x, y):
    return x + y
```

参照透過ではない例:
```python
counter = 0

def count_calls():
    global counter
    counter += 1
    return counter
```

本問題に関しては、下記のように返しても良い。
```python
def is_word_segmented(substring: str) -> bool:
    if substring == s:
        return True

    for word in wordDict:
        next_substring = substring + word
        if s.startswith(next_substring) and next_substring not in visited:
            visited.add(next_substring)
            if is_word_segmented(next_substring):
                return True
    return False
```

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        is_segmented = False
        visited = set()

        def check_is_segmented(prefix: str) -> None:
            if prefix == s:
                nonlocal is_segmented
                is_segmented = True
            
            for word in wordDict:
                next_prefix = prefix + word
                if s.startswith(next_prefix) and next_prefix not in visited:
                    check_is_segmented(next_prefix)
                    visited.add(next_prefix)

        check_is_segmented("")
        return is_segmented
```

