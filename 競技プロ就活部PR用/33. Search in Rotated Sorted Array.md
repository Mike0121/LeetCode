方針:
1. 境界(最小値)を見つける
2. targetが右側 or 左側かを、最小値 ~ 配列の右端までと比較して判断 
3. targetが右(or 左)側の場合、右(or 左)側で二分探索
4. 見つからなかった場合、return -1

## 二分探索による解法
* 時間計算量: O(logN)
* 空間計算量: O(logN)

### 1回目 (15m32s)
* 特に、最後にif分岐で右側にtargetがあった場合にmin_index文の調整を行なっている部分が気になる。(やや読みづらい。)

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_minimum_index(arr):
            left = 0
            right = len(arr)

            while left < right:
                mid = (left + right) // 2

                if nums[mid] <= nums[-1]:
                    right = mid
                else:
                    left = mid + 1

            return left

        def binary_search(arr, target):
            left = 0
            right = len(arr)
            while left < right:
                mid = (left + right) // 2
                if arr[mid] == target:
                    return mid
                elif arr[mid] > target:
                    right = mid
                else:
                    left = mid + 1
            return -1
                
        min_index = find_minimum_index(nums)
        min_value = nums[min_index]
        copied_nums = nums.copy()
        if nums[min_index] <= target <= nums[-1]:
            result = binary_search(copied_nums[min_index: len(nums)], target)
            return result + min_index if result != -1 else -1
        else:
            return binary_search(copied_nums[0: min_index], target)
```



### 2回目
下記の点を変更:
* 型の明記
* binary_sarch関数にleft, rightを指定して、また、numsに対して直接変更を加えることで最後のif分岐をより簡潔に
```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_minimum_index(arr: List[int]) -> int:
            left = 0
            right = len(arr)

            while left < right:
                mid = (left + right) // 2
                if arr[mid] <= arr[-1]:
                    right = mid
                else:
                    left = mid + 1
            return left

        def binary_search(left: int, right: int, target: int) -> int:
            while left < right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid
            return -1
        left = 0
        right = len(nums)
        min_index = find_minimum_index(nums)
        if nums[min_index] <= target <= nums[-1]:
            left = min_index
        else:
            right = min_index

        return binary_search(left, right, target)
```


### 3回目
* 変更なし
```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_minimum_index(arr: List[int]) -> int:
            left = 0
            right = len(arr)

            while left < right:
                mid = (left + right) // 2
                if arr[mid] <= arr[-1]:
                    right = mid
                else:
                    left = mid + 1
            return left

        def binary_search(left: int, right: int, target: int) -> int:
            while left < right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    right = mid
            return -1

        left = 0
        right = len(nums)
        min_index = find_minimum_index(nums)
        if nums[min_index] <= target <= nums[-1]:
            left = min_index
        else:
            right = min_index

        return binary_search(left, right, target)

```


## bisectを利用した解法
* 時間計算量: O(logN)
* 空間計算量: O(logN)

```
from bisect import bisect_left
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        min_index = bisect_left(nums, True, key=lambda x: x <= nums[-1])
    
        if nums[min_index] <= target <= nums[-1]:
            left = min_index
        else:
            right = min_index
        
        target_index = bisect_left(nums, target, left, right)
    
        if nums[target_index] == target:
            return target_index
        else:
            return -1
```


## 1回の二部探索で解く方法
* 個人的に読みづらかったため。今回は一旦パス
