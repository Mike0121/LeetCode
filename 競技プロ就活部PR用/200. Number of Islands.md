
> 疑問・質問
> DFS, BFSがこの問題でどのように区別されるのかいまいちわかってない。(何を持ってDFS、BFSとするのか。)
> 再帰 = DFS, スタック = BFS?


## 再帰による解法
時間計算量: O(N*M)<br>
空間計算量: O(N*M)<br>
### 1回目 (06m03s)
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        grid_height = len(grid)
        grid_width = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        
        def fill_adjacent_islands(h, w):
            if h < 0 or grid_height - 1 < h or w < 0 or grid_width - 1 < w or grid[h][w] == '0':
                return 0
            grid[h][w] = '0'
            for move in moves:
                fill_adjacent_islands(h + move[0], w + move[1])
            return 1
            
        num_island = 0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                num_island += fill_adjacent_islands(i, j)
        return num_island
```

> セルフツッコミ
> for move in movesよりも、for move_h, move_w in movesが良いと感じた。<br>
> grid_height, grid_widthはこの程度であれば1行で宣言してしまっても良いかもしれないが、書いたら少し見づらかったのでこのまま。<br>
> grid_width <= w　の方が見やすいと感じた。<br>
> num_island　-> num_island"s"<br>
> 最後のfor文でも、grid_height, grid_widthを使える。<br>
> gridを直接変更しているが、場合によってはコピーを考慮。<br>

### 2回目
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        grid_height = len(grid)
        grid_width = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        
        def fill_adjacent_islands(h, w):
            if h < 0 or grid_height <= h or w < 0 or grid_width <= w or grid[h][w] == "0":
                return 0

            grid[h][w] = "0"
            for move_h, move_w in moves:
                fill_adjacent_islands(h + move_h, w + move_w)

            return 1

        num_islands = 0
        for i in range(grid_height):
            for j in range(grid_width):
                num_islands += fill_adjacent_islands(i, j)
        return num_islands
```


> 他の方のコメントを参照に、下記を変更。
> WATER, ISLANDに分ける。(可読性の向上)<br>
### 3回目
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        WATER = '0'
        ISLAND = '1'

        grid_height = len(grid)
        grid_width = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        
        def fill_adjacent_islands(h, w):
            if h < 0 or grid_height <= h or w < 0 or grid_width <= w or grid[h][w] == WATER:
                return 0

            grid[h][w] = WATER
            for move_h, move_w in moves:
                fill_adjacent_islands(h + move_h, w + move_w)

            return 1

        num_islands = 0
        for i in range(grid_height):
            for j in range(grid_width):
                num_islands += fill_adjacent_islands(i, j)
        return num_islands
```

## スタックによる解法
時間計算量: O(N*M)<br>
空間計算量: O(N*M)<br>
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        grid_height = len(grid)
        grid_width = len(grid[0])
        moves = [[1, 0], [0, 1], [-1, 0], [0, -1]]

        def fill_island(start_h, start_w):
            next_positions = deque([(start_h, start_w)])
            while next_positions:
                h, w = next_positions.popleft()
                if 0 <= h < grid_height and 0 <= w < grid_width and grid[h][w] == '1':
                    grid[h][w] = '0'
                    for move_h, move_w in moves:
                        next_positions.append((h + move_h, w + move_w))
                
        num_islands = 0
        for i in range(grid_height):
            for j in range(grid_width):
                if grid[i][j] == '1':
                    fill_island(i, j)
                    num_islands += 1

        return num_islands
```

## UnionFindによる解法
一旦スキップ。時間に余裕ある時にUnion-Findの実装含めて取り組む。

