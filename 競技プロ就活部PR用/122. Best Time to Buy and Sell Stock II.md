
### 問題全体:
DPは、`121. Best Time to Buy and Sell Stock` と同様に2次元のテーブルを作成すれば
売り買いを表現できそう。ただ、もう少し楽なやり方がないか考え、グラフを書いた。
結局トータルでの売買の利益を求める問題であっても、前日と比較して
- 株価が高ければ利益を埋める
- 同じ or 下がっている場合は何もしない
のいずれかのパターンしかないため、これをコードにした解法(Greedy?)の方が好み。

Greedyがいまだにどういうアルゴリズムが具体的にはわかっていなかったため調べたが、
> 最適化問題を解くとき，計算の各段階で最も利益の大きい部分解を選んでいき，
> それらの部分解を組み合わせたものを最終的な解とする．
とあったが、問題として事前に気づくのが難しいかも感じている。

今回の問題は、252. Meeting Roomsに少し似ている感覚があり、グラフを書けば別にある程度パターン化できそう
と気づけたのでよかった。


### 参照:
https://github.com/olsen-blue/Arai60/pull/38
https://github.com/nittoco/leetcode/pull/44
https://github.com/TORUS0818/leetcode/pull/40
https://github.com/goto-untrapped/Arai60/pull/59
https://github.com/rossy0213/leetcode/pull/25
https://github.com/sakupan102/arai60-practice/pull/39
https://github.com/shining-ai/leetcode/pull/38
https://github.com/hayashi-ay/leetcode/pull/56

### 想定テストケース:
1. 正常系 (正解あり)
[1, 2, 3]
Output: 2

2. 正常系 (正解あり、売買なし)
[3, 2, 1]
Output: 0

3. 正常系 (計算量最大)
[1, 2, 3, 4, 5, ... , 3 * 10^4]
Output: 3 * 10^4 - 1

計算回数はO(N)とすると、3 * 10^4回の計算。
Pythonの処理速度 10^6〜10^7 Hzとして、3 * 10^4 // 10^6 = 0.05秒程度。

4. 例外
[]
Output: 例外ケースが必要

```
if not prices:
    raise ValueError("The input array prices is empty.")
```

5. 例外
[-1, -2, -3]
Output: 0


## Greedyによる解法
* 時間計算量: O(N)
* 空間計算量: O(1)

### 1回目 (10m10s)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        total_profit = 0
        for day in range(1, len(prices)):
            if prices[day] - prices[day - 1] >= 0:
                total_profit += prices[day] - prices[day - 1]
    
        return total_profit
```

### 2回目
* 先日との差分は別変数でおいた方がみやすい。
* 初見でtotal_profit += prices[day] - prices[day - 1]はちょっと困惑すると思った。
* if分岐させずに最大を取っていけば良い。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        total_profit = 0
        for day in range(1, len(prices)):
            profit = prices[day] - prices[day - 1]
            total_profit = max(total_profit, total_profit + profit)

        return total_profit
```


### 3回目
他の人の解法をみて感じたこと
* 初日かのflagを設定してrangeを0はじまりに簡潔にする方法があったが、自分的には少しやりすぎかと。
* 価格が下がっていたらcontinueしているのもあった。これはより直感的かも。
* 自分の変数名は特に違和感なさそう。
* 下記の言語化はわかりやすい。`[1, 3, 7]`とあったときに「1で買って7で売る」のと「1で買って3で売って、3で買って7で売る」のはおなじになる。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        total_profit = 0
        for day in range(1, len(prices)):
            profit = prices[day] - prices[day - 1]
            total_profit = max(total_profit, total_profit + profit)

        return total_profit
```

## DP
* 時間計算量: O(N)
* 空間計算量: O(N) (テーブルを用意), O(1) (変数で保持)

### 1回目
> profits[day][0]: day時点で株を持っていない場合の最大利益
> profits[day][1]: day時点で株を持っている場合の最大利益 として、毎日下記の更新規則で更新する。
> 昨日株を持っていなかった状態 (今日何もしない) vs 今日株を売って株を持っていない状態
> 昨日株を持っている状態 (今日何もしない) vs 昨日株を持っていなくて今日買った状態
> 最終的に持っていない場合の日付が最大の可能利益

* 読みづらいと感じるため、改善案は他の人のコードを探る。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profits = [[0] * 2 for _ in range(len(prices))]
        profits[0][0] = 0
        profits[0][1] = -prices[0]

        for day in range(1, len(prices)):
            price = prices[day]
            profits[day][0] = max(profits[day - 1][0], profits[day - 1][1] + price)
            profits[day][1] = max(profits[day - 1][1], profits[day - 1][0] - price)

        return profits[-1][0]
```

## 2回目
* 株を持っている、持っていない状態を、それぞれ、HOLD_STOCK, NOT_HOLD_STOCKの変数としておく。
* 2次元でもいいですが、配列2本のほうが読みやすいかもしれません。(趣味の範囲でしょう。)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        NOT_HOLD_STOCK = 0
        HOLD_STOCK = 1

        profits = [[0] * 2 for _ in range(len(prices))]
        profits[0][NOT_HOLD_STOCK] = 0
        profits[0][HOLD_STOCK] = -prices[0]

        for day in range(1, len(prices)):
            price = prices[day]
            profits[day][NOT_HOLD_STOCK] = max(profits[day - 1][NOT_HOLD_STOCK], profits[day - 1][HOLD_STOCK] + price)
            profits[day][HOLD_STOCK] = max(profits[day - 1][HOLD_STOCK], profits[day - 1][NOT_HOLD_STOCK] - price)

        return profits[-1][NOT_HOLD_STOCK]
```

### 3回目
* 配列2本でも書いてみる。
* これは確かにわかりやすいかもしれない。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        not_hold = [0] * len(prices)
        hold = [0] * len(prices)

        hold[0] = -prices[0]
        not_hold[0] = 0

        for day in range(1, len(prices)):
            price = prices[day]
            not_hold[day] = max(not_hold[day - 1], hold[day - 1] + price)
            hold[day] = max(hold[day - 1], not_hold[day - 1] - price)

        return not_hold[-1]
```


### 4回目
* 変数におくことで、空間計算量を改善できる。
* この書き方をした場合、上のDP(前日の値と比較)と更新式が異なるので注意。


```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cash = 0 
        hold = float('inf')
        
        for price in prices:
            cash = max(cash, price - hold)
            hold = min(hold, price - cash)

        return cash
```
* 下記のように書いた場合でもACするが、holdが当日のcashを参照しているのでロジックとして適切ではない気がする。(当日に売り買いをどちらもすることになる？)

```
prices = [1, 100, 2]の時
 day          0   1    2
cash          0 - 99 - 99
                ×    ×
hold          -1- -1 - 97

変数の場合

 day          0   1     2
cash          0 - 99 -  99
                \ |  ×  |
hold          -1- 0 -  97
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        cash = 0 
        hold = float('inf')
        
        for price in prices:
            cash = max(cash, price - hold)
            hold = min(hold, price - cash)

        return cash
```

```
