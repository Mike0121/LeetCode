参考コメント:
https://github.com/Yoshiki-Iwasa/Arai60/pull/35#discussion_r1699552857

```
1. [false, false, ..., false, true, true, ..., true] の切れ目を探す。
2. [false, false, ..., false, true, true, ..., true] のうち一番初めの true を探す。
といった設定が多いと思います。
```

めぐる式:
https://x.com/meguru_comp/status/697008509376835584?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E697008509376835584%7Ctwgr%5E610eb9b1d0a5d0c4de5c07ea93b0c71ff9cd2b9a%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fcore-tech.jp%2Fblog%2Ftech_log%2F2028%2F
https://qiita.com/drken/items/97e37dd6143e33a64c8c



自分用復習メモ
```
1. 閉区間 ↔︎ a ≤ x ≤ b ↔︎ left = 0, right = len(nums) - 1 
   以上、以下の範囲で探索を行うため右端を調査対象に含むべき ↔︎ while left <= right
2. 半開区間 ↔︎ a ≤ x < b ↔︎ left = 0, right = len(nums)
   以上、より小さいの範囲で探索を行うため右端を調査対象に含まない ↔︎ while left < right

半開区間のleftは、left = rightかつ、重複がなければ挿入されるべき位置に収束する。
```

二分探索で解けることは分かったとして(整列された配列)、大->小の切り替わりを探すため、1に該当する。
半開区間で考えて、初期値: left, right = 0, len(nums)とループの終了条件: while left < rightを固定する。
半開区間のため、更新式はleft = mid + 1, right = midで良い。
この場合、最後まで二分探索を行えば良いかと考えたが、今回はtargetがないため、右端の値をtargetと見立てて、
[false, false, ..., false, true, true, ..., true] の切れ目を探す。最終的なleftが切れ目になる。[..., False, [True)...]
また、nums[mid] == 右端の場合、右端2つの値のどちらかにある状況のため、rightを-1してもう一度二分探索を行う。


##半開区間による解法
* 時間計算量: O(logN)
* 空間計算量: O(1)

### 1回目 (30m24s)
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums)

        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[-1]:
                right = mid
            elif nums[mid] > nums[-1]:
                left = mid + 1
            else:
                right -= 1
            
        return nums[left]
```


### 2回目
* rightは特別扱いしなくても、if nums[mid] <= nums[-1]:で良い。
* 問題の性質上、nums[-1]はnums[right]で書き換え可能。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            if nums[mid] <= nums[right]:
                right = mid
            else:
                left = mid + 1

        return nums[left]
```


### 3回目
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2

            if nums[mid] <= nums[-1]:
                right = mid
            else:
                left = mid + 1

        return nums[left]
```

## 閉区間による解法
* 時間計算量: O(logN)
* 空間計算量: O(1)

初期値: left, right = 0, len(nums) - 1
条件式: left <= right
にしようと考えたが、問題に合わせて調整する必要があったので、半開区間で考えた方がわかりやすい。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[right]:
                right = mid
            else:
                left = mid + 1

        return nums[left]
```

## bisectによる解法
* Document: https://docs.python.org/3/library/bisect.html
* Cpython : https://github.com/python/cpython/blob/main/Lib/bisect.py
* ドキュメントにTrue, Falseの使い方が書いてないようだったので、実装を見た。
* key(a[mid]) < xで、右端の値とのTrue, Falseを評価し、一番左側にある、右端以下の値を見つけてる。
ChatGPT

```python
def bisect_left(a, x, lo=0, hi=None, *, key=None):
    """Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.

    A custom key function can be supplied to customize the sort order.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    # Note, the comparison uses "<" to match the
    # __lt__() logic in list.sort() and in heapq.
    if key is None:
        while lo < hi:
            mid = (lo + hi) // 2
            if a[mid] < x:
                lo = mid + 1
            else:
                hi = mid
    else:
        while lo < hi:
            mid = (lo + hi) // 2
            if key(a[mid]) < x:
                lo = mid + 1
            else:
                hi = mid
    return lo
```

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        index = bisect_left(nums, True, key=lambda x: x <= nums[-1])
        return nums[index]
```

## 再帰による解法
* 参考: https://github.com/fhiyo/leetcode/pull/43/commits/5f02850f0a2587bc30f3152fe1e28c5c36482a87
```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        def find_min_helper(left: int, right: int) -> int:
            if left == right:
                return nums[left]
            mid = (left + right) // 2
            if nums[mid] <= nums[-1]:
                return find_min_helper(left, mid)
            return find_min_helper(mid + 1, right)

        return find_min_helper(0, len(nums) - 1)
```
