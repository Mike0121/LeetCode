## HashMapを利用した解法 (10m23s)
* 時間計算量: O(N)
* 空間計算量: O(N)

### 1回目
* とりあえず思いついた解法で。
* two-pointersよりも、面接だったらこっちを先に思いつく気がする。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
from collections import defaultdict
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head

        nodes_count = defaultdict(int)
        current = head
        while current:
            nodes_count[current.val] += 1
            current = current.next

        dummy = ListNode(0)
        dummy.next = head
        current = dummy

        while current.next:
            if nodes_count[current.next.val] > 1:
                current.next = current.next.next
                continue
            current = current.next

        return dummy.next
```

### 2回目
* dummy = ListNode(0, head)で1行で書ける。
* 最初のif not head or not head.next:は、if not headで十分

```python
from collections import defaultdict
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        nodes_count = defaultdict(int)
        current = head
        while current:
            nodes_count[current.val] += 1
            current = current.next

        dummy = ListNode(0, head)
        current = dummy

        while current.next:
            if nodes_count[current.next.val] > 1:
                current.next = current.next.next
                continue
                
            current = current.next

        return dummy.next
```

### 3回目
* nodes_countの複数形が違和感あったので、value_counterに変更。(nodeそのものをカウントしているわけではないため)
* while内のif-continueをwhileに書き換えた方が、複数の重複があった場合に効率的なため書き換え。

```python
from collections import defaultdict
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        
        current = head
        value_counter = defaultdict(int)
        while current:
            value_counter[current.val] += 1
            current = current.next

        dummy = ListNode(0, head)
        current = dummy

        while current.next:
            while current.next and value_counter[current.next.val] > 1:
                current.next = current.next.next

            if current.next:
                current = current.next

        return dummy.next
```

## two-pointersによる解法
* 時間計算量: O(N)
* 空間計算量: O(1)

* 思いつかなかったと同時に、理解するまでにいつもより時間を要した。

```python
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy_head = ListNode(0, head)
        slow = dummy_head
        fast = head
    
        while fast and fast.next:
            while fast.next and fast.val == fast.next.val:
                fast = fast.next
            if slow.next != fast:
                slow.next = fast.next
            else:
                slow = slow.next
            fast = fast.next
        return dummy_head.next
```
