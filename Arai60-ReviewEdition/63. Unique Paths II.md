### 問題全体:
Unique Pathの解法が頭に入っていたため、特に苦労はせず。
Arai60の中では発想が試される問題と感じた。

### 参照:
https://github.com/Fuminiton/LeetCode/pull/34
https://github.com/fuga-98/arai60/pull/34
https://github.com/olsen-blue/Arai60/pull/34
https://github.com/hroc135/leetcode/pull/32
https://github.com/TORUS0818/leetcode/pull/36
https://github.com/Ryotaro25/leetcode_first60/pull/40
https://github.com/fhiyo/leetcode/pull/35
https://github.com/goto-untrapped/Arai60/pull/33
https://github.com/YukiMichishita/LeetCode/pull/15
https://github.com/sakupan102/arai60-practice/pull/35
https://github.com/shining-ai/leetcode/pull/34#pullrequestreview-1966388686
https://github.com/hayashi-ay/leetcode/pull/44

### 想定テストケース: (今回は詳細はスキップ)
1. 正常系 (ブロックあり)
2. 正常系 (ブロックなし)
3. 異常系 (obstacleGridが空)

## DPによる解法
* 時間計算量: O(h * w)
* 空間計算量: O(h * w) (dpテーブル分)
h: Gridの高さ, w: Gridの幅

### 1回目 (8m21s)
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        num_cols = len(obstacleGrid[0])
        num_rows = len(obstacleGrid)
        num_ways = [[0] * num_cols for _ in range(num_rows)]

        for col in range(num_cols):
            if obstacleGrid[0][col] == 1:
                break
            num_ways[0][col] = 1
        
        for row in range(num_rows):
            if obstacleGrid[row][0] == 1:
                break
            num_ways[row][0] = 1

        for col in range(1, num_cols):
            for row in range(1, num_rows):
                if obstacleGrid[row][col] == 1:
                    continue

                num_ways[row][col] = num_ways[row - 1][col] + num_ways[row][col - 1]

        return num_ways[num_rows - 1][num_cols - 1]
```

### 2回目
* OBSTACLEは変数化した方が(自分にも)読みやすい。

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        OBSTACLE = 1
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_ways = [[0] * num_cols for _ in range(num_rows)]

        for row in range(num_rows):
            if obstacleGrid[row][0] == OBSTACLE:
                break
            num_ways[row][0] = 1

        for col in range(num_cols):
            if obstacleGrid[0][col] == OBSTACLE:
                break
            num_ways[0][col] = 1

        for row in range(1, num_rows):
            for col in range(1, num_cols):
                if obstacleGrid[row][col] == OBSTACLE:
                    continue
                num_ways[row][col] = num_ways[row - 1][col] + num_ways[row][col - 1]           

        return num_ways[num_rows - 1][num_cols - 1]
```


### 3回目

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        OBSTACLE = 1
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        num_ways = [[0] * num_cols for _ in range(num_rows)]

        for row in range(num_rows):
            if obstacleGrid[row][0] == OBSTACLE:
                break
            num_ways[row][0] = 1

        for col in range(num_cols):
            if obstacleGrid[0][col] == OBSTACLE:
                break
            num_ways[0][col] = 1

        for row in range(1, num_rows):
            for col in range(1, num_cols):
                if obstacleGrid[row][col] == OBSTACLE:
                    continue
                num_ways[row][col] = num_ways[row - 1][col] + num_ways[row][col - 1]           

        return num_ways[num_rows - 1][num_cols - 1]
```


## DFSによる解法
* 時間計算量: O(h * w)
* 空間計算量: O(h * w) + O(h + w) (メモ分 + 再帰スタック分)
h: Gridの高さ, w: Gridの幅

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        num_rows = len(obstacleGrid)
        num_cols = len(obstacleGrid[0])
        moves = [[0, 1], [1, 0]]
        memo = {}

        def is_valid_grid(row: int, col: int) -> bool:
            return 0 <= row < num_rows and 0 <= col < num_cols and obstacleGrid[row][col] == 0

        def count_nums_ways(start_row: int, start_col: int) -> int:
            if is_valid_grid(start_row, start_col) == False:
                return 0

            if start_row == num_rows - 1 and start_col == num_cols - 1 :
                return 1

            if (start_row, start_col) in memo:
                return memo[(start_row, start_col)]

            count = 0

            for row_move, col_move in moves:
                count += count_nums_ways(start_row + row_move, start_col + col_move)

            memo[(start_row, start_col)] = count
            
            return count

        return count_nums_ways(0, 0)
```

