
### 問題全体：
結構複雑に感じたので、問題を分析してみる。
1. 最短のpathを見つければ良いのでendWordにたどり着いたらすぐreturnできる
2. ある文字を1文字変更した際に対応する文字のリストが欲しいので、先に各wordから派生しうるパターンを作ってしまう。ここは関数化しても良いかも。
3. 最終的に辿り着く文字はあくまで1文字ずつ現在の文字を変えたものになる
4. ある文字から隣接している文字を見るには、1つ1つ取り出すBFSではなく、毎ループで次の候補全体を見る必要がある。
5. 通った文字を記録しておかないと無限ループになる。

これを踏まえた上で、BFSとしてMapをベースに1文字ずつ文字を変えていき、endwordに辿り着き次第
そのcountを返せば良いということがわかった。一旦計算量は特に気にせずに書く。

### 参照:
https://github.com/irohafternoon/LeetCode/pull/22
https://github.com/Fuminiton/LeetCode/pull/20
https://github.com/SuperHotDogCat/coding-interview/pull/45
https://github.com/ryoooooory/LeetCode/pull/23
https://github.com/tshimosake/arai60/pull/11
https://github.com/t0hsumi/leetcode/pull/20
https://github.com/olsen-blue/Arai60/pull/20
https://github.com/Hurukawa2121/leetcode/pull/20
https://github.com/katataku/leetcode/pull/18
https://github.com/colorbox/leetcode/pull/34
https://github.com/tarinaihitori/leetcode/pull/20
https://github.com/Yusan1234/arai60/pull/1
https://github.com/nittoco/leetcode/pull/36
https://github.com/Ryotaro25/leetcode_first60/pull/22
https://github.com/TORUS0818/leetcode/pull/22
https://github.com/kazukiii/leetcode/pull/21
https://github.com/fhiyo/leetcode/pull/22
https://github.com/sakupan102/arai60-practice/pull/20
https://github.com/hayashi-ay/leetcode/pull/42


### 想定テストケース:
1. 正常系 (正解あり)
beginWord = "aaa"
endWord = "abc"
wordList = ["aba", "abc"]
Output: 2

2. 正常系 (正解あり、正解なし)
beginWord = "aaa"
endWord = "ddd"
wordList = ["aba", "abc"]
Output: 0

3. 正常系 (計算量最大)
beginWord = "aaaaaaaaa"
endWord = "bbbbbbbbbb"
wordList = ["aaaaaaaab", "aaaaaaabb", "aaaaaabbb", ... "zzzzzzzz"]
Output: 10

4. 正常系 (ループあり)
beginWord = "aaa"
endWord = "bbb"
wordList = ["ddd", "ccc"]
Output: 0

5. 例外
beginWord = ""
endWord = ""
wordList = []
Output: 例外ケースが必要

6. 例外 (長さの違うword)
beginWord = "aaaaaaaaa"
endWord = "bbbbbbbbbb"
wordList = ["aaaaaaaab", "aaaaaaabb", "aaaaaabbb", ... "zzzzzzzz"]
Output: wordをリプレースしていく方法の場合、計算が続くので問題ない。
        特殊なレーベンシュタイン距離を計算する場合、例外ケースが必要 or 異常値を除いて計算をつづける処理が必要。


## BFSによる解法
* 時間計算量: O(N^2 * L)
* 空間計算量: O(N * L)
N: 単語数, L: 単語の長さ
### 1回目
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0

        adjanct_to_word = defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                adjanct_to_word[word[:i] + "*" + word[i + 1:]].append(word)

        next_words = deque([beginWord])
        visited = set(beginWord)
        path_length = 1

        while next_words:
            for i in range(len(next_words)):
                word = next_words.popleft()
                if word == endWord:
                    return path_length

                for j in range(len(word)):
                    match_pattern = word[:j] + "*" + word[j + 1:]
                    for next_word in adjanct_to_word[match_pattern]:
                        if next_word not in visited:
                            visited.add(next_word)
                            next_words.append(next_word)

            path_length += 1

        return 0
```


### 2回目
* whileループ直後のiは使っていないので置き換え
* path_lengthは、next_wordsの中に入れていって更新する形の方が良さそう。
* 1文字違いのマッチするパターンを考える際に、"*"で良いのかは要議論。
* wordListはsetに入れた方が重複があった場合に計算量を大きく減らせる。
* ここまでは他人の回答を見ずに修正案を考えているが、ネストが深いのが気になる。→関数化できれば良いか。

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        unique_word_list = set(wordList)
        if endWord not in unique_word_list:
            return 0

        adjanct_to_word = defaultdict(list)
        for word in unique_word_list:
            for i in range(len(word)):
                adjanct_to_word[word[:i] + "*" + word[i + 1:]].append(word)

        next_words = deque([(beginWord, 1)])
        visited = set(beginWord)

        while next_words:
            for _ in range(len(next_words)):
                word, path_length = next_words.popleft()
                if word == endWord:
                    return path_length

                for j in range(len(word)):
                    match_pattern = word[:j] + "*" + word[j + 1:]
                    for next_word in adjanct_to_word[match_pattern]:
                        if next_word not in visited:
                            visited.add(next_word)
                            next_words.append((next_word, path_length + 1))

        return 0
```


### 3回目
* 1文字違いの判定を特殊ケースのレーベンシュタイン距離で文字の距離が1文字違いかを判定
* continueを使ってネストを浅くする。(すこ読みづらいかも)

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        unique_word_list = set(wordList)
        if endWord not in unique_word_list:
            return 0

        def is_adjanct_words(word1, word2):
            distance = 0
            for w1, w2 in zip(word1, word2):
                if w1 != w2:
                    distance += 1
                    if distance <= 1:
                        continue
                    return False
            return True

        next_words = deque([(beginWord, 1)])
        visited = set(beginWord)

        while next_words:
            for _ in range(len(next_words)):
                word, shortest_path = next_words.popleft()
                if word == endWord:
                    return shortest_path

                for next_word in unique_word_list:
                    if next_word in visited or not is_adjanct_words(word, next_word):
                        continue
                    visited.add(next_word)
                    next_words.append((next_word, shortest_path + 1))
        
        return 0
                        
```

## Generatorを利用した解法
* 時間計算量: O(N^2 * L)
* 空間計算量: O(N * L)
N: 単語数, L: 単語の長さ

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        unique_word_list = set(wordList)
        if not endWord in unique_word_list:
            return 0

        def generate_adjanct_words(word: str) -> Generator[str, None, None]:
            for i in range(len(word)):
                for letter in string.ascii_lowercase:
                    adjanct_word = word[:i] + letter + word[i+1:]
                    if adjanct_word not in unique_word_list:
                        continue
                    unique_word_list.remove(adjanct_word)
                    yield adjanct_word

        
        shortest_path = 1
        words = [beginWord]
        while words:
            next_words = []
            for word in words:
                if word == endWord:
                    return shortest_path

                for next_word in generate_adjanct_words(word):
                    next_words.append(next_word)
                
            shortest_path += 1
            words = next_words

        return 0
```
