## DPによる解法
* 時間計算量: O(N)
* 空間計算量: O(1)

### 1回目 (15m21s (解答参照))
* 手が止まった問題。
  試したこととして、数学的に解けないか、DPを使ってどのように定式化するかを考えたが、
  適切な場合分けが思いつかなかったため解法を見た。
* 反省点として、1番目、2番目、3番目のみに注目して考えれば良かった。

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k

        num_of_paints = [0] * (n + 1)
        num_of_paints[1] = k
        num_of_paints[2] = k * k

        for i in range(3, n + 1):
            num_of_paints[i] = (k - 1) * (num_of_paints[i - 1] + num_of_paints[i - 2])

        return num_of_paints[-1]     
```


### 2回目
* 問題の制約から今回はないが、n = 0 or k = 0の場合を加えても良いかも。
* num_of_paintsより、paint_waysの方がより明瞭。
* 参照していた以前の自分の解法がdpの長さを(インデックス合わせるために)n+1としていたが、特にメリットを感じないため修正。
* DPテーブルを利用せずに、変数でおいても解けることは気づけた。(別解として記載。)

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k

        paint_ways = [0] * n
        paint_ways[0] = k
        paint_ways[1] = k * k

        for i in range(2, n):
            paint_ways[i] = (k - 1) * (paint_ways[i - 1] + paint_ways[i - 2])
            
        return paint_ways[-1]
```


### 3回目
* 2回目から変更なし
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k

        paint_ways = [0] * n
        paint_ways[0] = k
        paint_ways[1] = k * k

        for i in range(1, n):
            paint_ways[i] = (k - 1) * (paint_ways[i - 1] + paint_ways[i - 2])

        return paint_ways[-1]
```

## メモ化再帰(with キャッシュ)による解法
* 時間計算量: O(N)
* 空間計算量: O(N)

Document: https://docs.python.org/3/library/functools.html#functools.lru_cache
```LRUの意味
An LRU (least recently used) cache works best when the most recent calls are the best predictors of
upcoming calls (for example, the most popular articles on a news server tend to change each day).
The cache’s size limit assures that the cache does not grow without bound on long-running processes such as web servers.
```
今回の場合、1 <= n <= 50の制約から、defaultのmaxsize = 128で十分。(50で良い。)
キャッシュの理解が曖昧なのと良く聞かれることなので、次は146. LRU Cache (https://leetcode.com/problems/lru-cache/) を解く。

```python
class Solution:
    @lru_cache
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k
        return (k - 1) * (self.numWays(n - 1, k) + self.numWays(n - 2, k))
```


### メモ化再帰(with dictによるメモ)による解法
* 時間計算量: O(N)
* 空間計算量: O(N)
```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        paint_ways_memo = {}

        def count_paint_ways(n):
            if n == 1:
                return k
            if n == 2:
                return k * k 
            
            if n in paint_ways_memo:
                return paint_ways_memo[n]
            
            different_ways = (k - 1) * count_paint_ways(n - 1)
            same_ways = (k - 1) * count_paint_ways(n - 2)
            paint_ways_memo[n] = different_ways + same_ways

            return paint_ways_memo[n]

        return count_paint_ways(n)
```


## 2変数による解法 (その1)
* 時間計算量: O(N)
* 空間計算量: O(1)

* DPをテーブルの代わりに2変数をおいて行う。

```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k
        if n == 2:
            return k * k
        
        two_prev_ways = k
        one_prev_ways = k * k

        for _ in range(2, n):
            target_ways = (k - 1) * (one_prev_ways + two_prev_ways)
            two_prev_ways = one_prev_ways
            one_prev_ways = target_ways

        return target_ways
```

## 2変数による解法 (その2)
* 時間計算量: O(N)
* 空間計算量: O(1)

* ある地点の塗り分けられる方法をそれぞれ別々にカウントしていく。
* 変数名が微妙かもしれない。

```python
'''
NOTE
B - B - B (same) ×
      - W (diff)
  - W - B (diff) 
      - W (same) 

W - B - B (same)
      - W (diff)
  - W - B (diff)
      - W (same) ×

i = 2(3番目) の場合を考えると、same_waysは、前回のdiff_waysと同じ。
なぜなら、same_waysとsame_waysを繋げると3連続になるため。
diff_waysは、DP同様、前回のsame_waysとdiff_waysから抽出(計算)されたもの。
'''
```


```python
class Solution:
    def numWays(self, n: int, k: int) -> int:
        if n == 1:
            return k

        diff_ways = k
        same_ways = 0

        for _ in range(1, n):
            new_diff_ways = (k - 1) * (same_ways + diff_ways)
            same_ways = diff_ways
            diff_ways = new_diff_ways

        return same_ways + diff_ways
```
