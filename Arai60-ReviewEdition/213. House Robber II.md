### 参照:
https://github.com/nanae772/leetcode-arai60/pull/35
https://github.com/akmhmgc/arai60/pull/31
https://github.com/h1rosaka/arai60/pull/38
https://github.com/shintaro1993/arai60/pull/40
https://github.com/potrue/leetcode/pull/36
https://github.com/Kazuryu0907/LeetCode_Arai60/pull/7
https://github.com/ryosuketc/leetcode_arai60/pull/49
https://github.com/tokuhirat/LeetCode/pull/36
https://github.com/Kaichi-Irie/leetcode-python/pull/6
https://github.com/ryoooooory/LeetCode/pull/39
https://github.com/irohafternoon/LeetCode/pull/39
https://github.com/Fuminiton/LeetCode/pull/36
https://github.com/fuga-98/arai60/pull/36
https://github.com/olsen-blue/Arai60/pull/36
https://github.com/hroc135/leetcode/pull/34
https://github.com/TORUS0818/leetcode/pull/38
https://github.com/Ryotaro25/leetcode_first60/pull/38
https://github.com/seal-azarashi/leetcode/pull/34
https://github.com/Yoshiki-Iwasa/Arai60/pull/51
https://github.com/fhiyo/leetcode/pull/37
https://github.com/seal-azarashi/leetcode/pull/34
https://github.com/Yoshiki-Iwasa/Arai60/pull/51
https://github.com/fhiyo/leetcode/pull/37
https://github.com/sakupan102/arai60-practice/pull/37
https://github.com/shining-ai/leetcode/pull/36
https://github.com/hayashi-ay/leetcode/pull/50

### 想定テストケース:
1. 正常系: 長さ2以上の配列
入力   : nums = [1, 2, 3]
想定出力: 3

2. 正常系: 末端に最大値
入力   : nums = [100, 1, 1, 99]
想定出力: 101

4. 正常系: 長さ1の配列
入力   : nums = [1]
想定出力: 1

5. 正常系: 長さ1000の配列 (想定ケース最大の配列長)
入力   : nums = [1, 1, 1, ...]
想定出力: 999

5. 例外系: 空の配列
入力    : []
想定出力:  0

※ numsの中に負の値があった場合も、エラーケースと合わせて考慮しても良い

## DPによる解法
* 時間計算量: O(N)
* 空間計算量: O(N) (テーブル分)
N: numsの長さ

### 1回目 (6m21s)
* 以前一度解いたことはあるが、覚えているわけではなかったので下記の手順で解いた。
* 198. House Robber(円形制約なし)の場合だったらどうするか → 円形をどうすればよいか → 関数化して2パターンのどちらかの最大値を取得
* 円形 → 最初と最後が隣り合っている → 最初と最後を落とした2つで最大値を取る

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        if len(nums) == 2:
            return max(nums[0], nums[1])

        def find_max_amount(nums: List[int]) -> int:
            max_amount = [-1] * len(nums)
            max_amount[0] = nums[0]
            max_amount[1] = max(nums[0], nums[1])

            for pos in range(2, len(nums)):
                val = nums[pos]
                max_amount[pos] = max(max_amount[pos - 2] + nums[pos], max_amount[pos - 1])

            return max_amount[-1]

        return max(find_max_amount(nums[1:]), find_max_amount(nums[:-1]))
```
### 2回目
* DPを使うのであれば、初期化の変数は切り出したほうが良い。(可読性、仕様変更時の保守性の観点から)
* テーブルを作成する代わりに、1つ前、2つ前の状態をそれぞれ変数でもつ。(空間計算量 O(N) → O(1)に改善)
* numsのコピーを発生させないため、補助関数に開始、終了位置を渡す。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        def find_max_amount(nums: List[int], begin: int, end: int) -> int:
            if end - begin == 1:
                return nums[begin]
            
            max_so_far = 0
            max_one_prev = 0
            max_two_prev = 0
            
            for pos in range(begin, end):
                max_so_far = max(max_one_prev, max_two_prev + nums[pos])
                max_two_prev = max_one_prev
                max_one_prev = max_so_far

            return max_so_far
            
        return max(find_max_amount(nums, 1, len(nums)), 
                   find_max_amount(nums, 0, len(nums) - 1))
```

### 3回目
* 関数内例外処理を追加
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        def find_max_amount(nums: List[int], begin: int, end: int) -> int:
            assert begin < end, "Error: begin index must be smaller than end index"
            if end - begin == 1:
                return nums[begin]
            
            max_so_far = 0
            max_one_prev = 0
            max_two_prev = 0
            
            for pos in range(begin, end):
                max_so_far = max(max_one_prev, max_two_prev + nums[pos])
                max_two_prev = max_one_prev
                max_one_prev = max_so_far

            return max_so_far
            
        return max(find_max_amount(nums, 1, len(nums)), 
                   find_max_amount(nums, 0, len(nums) - 1))
```
