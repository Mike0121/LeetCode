## DPによる解法 
### 1回目 (4m20s)
* 時間計算量: O(N)
* 空間計算量: O(N)
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums)

        max_money = [0] * len(nums)
        max_money[0] = nums[0]
        max_money[1] = max(nums[0], nums[1])
    
        for i in range(2, len(nums)):
            if max_money[i - 1] >= max_money[i - 2] + nums[i]:
                max_money[i] = max_money[i - 1]

            else:
                max_money[i] = max_money[i - 2] + nums[i]

        return max_money[-1]
```

### 2回目
* if len(nums) <= 2:の部分に関して、空の配列が入った場合はどうなるか？ -> maxでdefault値の設定可能。(設定値は議論)
Doument: https://docs.python.org/3/library/functions.html#func-memoryview
* 場合分けせずとも、maxで常に最大値を取り続ければ良い。
* max_money(物)より、max_values(目的)の方が分かりやすいと考えたので、変数名変更。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return max(nums, default = 0)

        max_values = [0] * len(nums)
        max_values[0] = nums[0]
        max_values[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            max_values[i] = max(max_values[i - 2] + nums[i], max_values[i - 1]) 

        return max_values[-1]
```

### 3回目
* len(nums) <= 1でもOK。
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return max(nums, default = 0)

        max_values = [0] * len(nums)
        max_values[0] = nums[0]
        max_values[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            max_values[i] = max(max_values[i - 2] + nums[i], max_values[i - 1])

        return max_values[-1]
```


## 2変数を利用した解法
* 時間計算量: O(N)
* 空間計算量: O(1)
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return nums[0]

        one_previous_max = 0
        two_previous_max = 0

        for num in nums:
            target_max = max(two_previous_max + num, one_previous_max)

            two_previous_max = one_previous_max
            one_previous_max = target_max 

        return target_max
```


## メモ化再帰による解法
* 時間計算量: O(N)
* 空間計算量: O(N)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        memo = {}

        def find_max_value(i: int) -> int:
            if i >= len(nums):
                return 0

            if i in memo:
                return memo[i]
                
            max_value = max(nums[i] + find_max_value(i + 2), find_max_value(i + 1))

            memo[i] = max_value
            return max_value

        return find_max_value(0)
```
